// -*- C++ -*- generated by wxGlade 0.6.3 on Tue Nov 01 01:42:24 2011

#include "JaneClone.h"

// boostの名前空間を使う
using namespace boost::asio;
using namespace std;

// enum
enum {
    ID_Quit = 1,
    ID_About,
    ID_GetBoardList,
    ID_GetVersionInfo,
};

// event table
BEGIN_EVENT_TABLE(JaneClone, wxFrame)
	// メニューバーにあるコマンド入力で起動するメソッドのイベントテーブル
    EVT_MENU(ID_Quit, JaneClone::OnQuit)
    EVT_MENU(ID_About, JaneClone::OnAbout)
    EVT_MENU(ID_GetBoardList, JaneClone::OnGetBoardList)
    EVT_MENU(ID_GetVersionInfo, JaneClone::OnVersionInfo)
END_EVENT_TABLE()


JaneClone::JaneClone(wxWindow* parent, int id, const wxString& title, const wxPoint& pos, const wxSize& size, long style):
    wxFrame(parent, id, title, pos, size, wxDEFAULT_FRAME_STYLE)
{
	// メニューバーの設置
	wxMenuBar *menuBar = new wxMenuBar;
    wxMenu *menu1 = new wxMenu;
    menu1->Append(ID_About, wxT("このソフトについて..."));
    menu1->Append(ID_Quit, wxT("終了"));

    wxMenu *menu2 = new wxMenu;
    wxMenu *menu3 = new wxMenu;
    menu3->Append(ID_GetBoardList, wxT("板一覧更新"));

    wxMenu *menu4 = new wxMenu;
    wxMenu *menu5 = new wxMenu;
    wxMenu *menu6 = new wxMenu;
    wxMenu *menu7 = new wxMenu;
    wxMenu *menu8 = new wxMenu;
    wxMenu *menu9 = new wxMenu;
    menu9->Append(ID_GetVersionInfo, wxT("バージョン情報を開く"));

    menuBar->Append(menu1, wxT("ファイル"));
    menuBar->Append(menu2, wxT("表示"));
    menuBar->Append(menu3, wxT("板一覧"));
    menuBar->Append(menu4, wxT("スレッド一覧"));
    menuBar->Append(menu5, wxT("お気に入り"));
    menuBar->Append(menu6, wxT("検索"));
    menuBar->Append(menu7, wxT("ウィンドウ"));
    menuBar->Append(menu8, wxT("ツール"));
    menuBar->Append(menu9, wxT("ヘルプ"));

    SetMenuBar(menuBar);// メニューバー設置終わり

    window_1 = new wxSplitterWindow(this, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxSP_3D|wxSP_BORDER);
    window_1_pane_2 = new wxPanel(window_1, wxID_ANY);
    window_2 = new wxSplitterWindow(window_1_pane_2, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxSP_3D|wxSP_BORDER);
    window_1_pane_1 = new wxPanel(window_1, wxID_ANY);

    //URL入力欄の表示部分
    label_1 = new wxStaticText(this, wxID_ANY, wxT("URL:"));
    textCtlForURL = new wxTextCtrl(this, wxID_ANY, wxEmptyString);
    button_1 = new wxButton(this, wxID_ANY, wxT("GO"));

    //板一覧を取得してツリー表示
    m_tree_ctrl = new wxTreeCtrl(window_1_pane_1, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    window_2_pane_1 = new wxPanel(window_2, wxID_ANY);
    window_2_pane_2 = new wxPanel(window_2, wxID_ANY);

    SetProperties();
    DoLayout();
    this->CreateStatusBar();
	this->SetStatusText(wxT(" 完了"));
}


void JaneClone::SetProperties()
{
    // wxGladeによる自動生成
    SetTitle(_("JaneClone"));
    SetSize(wxSize(960, 540));
    label_1->SetFont(wxFont(9, wxDEFAULT, wxNORMAL, wxNORMAL, 0, wxT("MS Shell Dlg 2")));

    // 板一覧情報を反映する
    wxImageList *treeImage = new wxImageList(16,16);
    wxBitmap idx1 = wxArtProvider::GetBitmap(wxART_FOLDER,wxART_OTHER );
    wxBitmap idx2 = wxArtProvider::GetBitmap(wxART_NEW,wxART_OTHER);
    treeImage->Add(idx1);
    treeImage->Add(idx2);
    m_tree_ctrl->AssignImageList(treeImage);

    m_treeData = new wxTreeItemData();
    m_rootId = m_tree_ctrl->AddRoot(wxT("2ch板一覧"), 0, 0, m_treeData);
}


void JaneClone::DoLayout()
{
    // 各種サイザー設定
    wxBoxSizer* sizer_1 = new wxBoxSizer(wxVERTICAL);
    wxBoxSizer* sizer_4 = new wxBoxSizer(wxHORIZONTAL);
    wxBoxSizer* sizer_3 = new wxBoxSizer(wxHORIZONTAL);
    wxBoxSizer* sizer_2 = new wxBoxSizer(wxHORIZONTAL);

    // 一番上のURL入力欄など
    sizer_2->Add(label_1, 0, wxALL|wxALIGN_RIGHT|wxALIGN_CENTER_VERTICAL, 0);
    sizer_2->Add(textCtlForURL, 2, wxALL|wxEXPAND, 0);
    sizer_2->Add(button_1, 0, 0, 0);
    sizer_1->Add(sizer_2, 0, wxALL|wxEXPAND, 2);

    // 下部のスプリットウィンドウの設定
    // Sizer3にツリーコントロールが入る
    sizer_3->Add(m_tree_ctrl, 1, wxEXPAND, 0);
    window_1_pane_1->SetSizer(sizer_3);

	// スプリットウィンドウ(横の区切り)
    window_2->SplitHorizontally(window_2_pane_1, window_2_pane_2);
    sizer_4->Add(window_2, 1, wxEXPAND, 0);
    window_1_pane_2->SetSizer(sizer_4);
    // スプリットウィンドウ(縦の区切り) - 最初は150程度にしておく
    window_1->SplitVertically(window_1_pane_1, window_1_pane_2, 150);
    sizer_1->Add(window_1, 1, wxEXPAND, 0);
    SetSizer(sizer_1);


    Layout();
    // end wxGlade
}

void JaneClone::OnQuit(wxCommandEvent&)
{
	Close(true);
}

void JaneClone::OnAbout(wxCommandEvent&)
{
}


// 板一覧更新処理
void JaneClone::OnGetBoardList(wxCommandEvent&) {
	// もし板一覧ファイルがdatフォルダに存在するならば一気に板一覧設定に飛ぶ
	if(wxFile::Exists(wxT("./dat/BoardListUTF8.html"))){
		JaneClone::SetBoardList();
	// そうでなければ板一覧をダウンロードしてくる
	}else{
		JaneClone::DownloadBoardList();
		JaneClone::DecommpressFile();
		JaneClone::ConvertSJISToUTF8();
		JaneClone::SetBoardList();
	}
}

// 板一覧ファイルをダウンロードする処理
void JaneClone::DownloadBoardList(){
    // ディレクトリ作成
    fs::path dir( "./dat" );
    fs::create_directory( dir );

    // menu.2ch.net の http サービスに接続
    ip::tcp::iostream s( "menu.2ch.net", "http" );

    // 送信
    s << "GET /bbsmenu.html HTTP/1.0 \r\n";
    s << "Accept-Encoding: gzip \r\n";
    s << "Host: menu.2ch.net \r\n";
    s << "Accept:  \r\n";
    s << "Referer: http://menu.2ch.net/ \r\n";
    s << "Accept-Language: ja \r\n";
    s << "User-Agent: Mozilla/5.0 \r\n";
    s << "Connection: close \r\n";
    s << "\r\n";
    s << flush;

    // 受信
    string line;
    bool flag = false;
    // gzipのヘッダ作成
    char HEX[] = {0x1f,0x8b,0x08,0x00};
    //  ios::binary はバイナリ形式で出力（省略するとアスキー形式で出力）
    fs::ofstream outputfilegzip( dir/"BoardList.gzip", std::ios::binary );

    while( getline(s, line) ){
	if ( flag ) {
	    // 真の場合
	    outputfilegzip << line << endl;
	} else {
	    // 偽の場合
	    unsigned int loc = line.find( *HEX , 0 );
	    if( loc != string::npos ) {
		outputfilegzip << line << endl;
		flag = true;
	    }
	}
    }
    outputfilegzip.close();
    line.clear();
}

// ダウンロードした板一覧ファイルを解凍する処理
void JaneClone::DecommpressFile(){
    // gzファイルをZlibを使って解凍する
    gzFile infile = gzopen("./dat/BoardList.gzip", "rb");
    FILE *outfile = fopen("./dat/BoardListSJIS.html", "wb");

    char buffer[128];
    int num_read = 0;
    while ((num_read = gzread(infile, buffer, sizeof(buffer))) > 0) {
	fwrite(buffer, 1, num_read, outfile);
    }

    // ファイルポインタを閉じる
    gzclose(infile);
    fclose(outfile);
}

// ダウンロードしたファイルの文字コードをShift-JISからUTF-8に変換する処理
void JaneClone::ConvertSJISToUTF8(){
    // 文字列変換処理
    // ファイルポインタの用意
    FILE *fp_sjis;
    int c_sjis;
    FILE *fp_utf8;
    int c_utf8;

    /* 読み込みモードでSJISのファイルをオープン */
	fp_sjis = fopen( "./dat/BoardListSJIS.html", "r" );
    /* 書き出しモードでSJISのファイルをオープン */
	fp_utf8 = fopen( "./dat/BoardListUTF8.html", "w" );

    // 判定用変数の準備
    char SJISHEX[3];
    // 変換テーブルから文字列を読み込むstring
    string lineTrans;

    // UTF-8への変換フラグ
    // flag_su 0:通常時 1:1文字目　2:2文字目
    int flag_su = 0;
    // 変換テーブル探索用文字列
    char search_table[5]; // 88a2\0　←　最終型

    // 変換ループ
    for(;;) {
	// SJISファイルを一文字ごとに読み出す
	c_sjis = fgetc( fp_sjis );

	// SJISファイルが最終の文字ならばループから抜ける
	if( c_sjis == EOF ) { break;}
	sprintf(SJISHEX, "%02x", (char*)c_sjis);
	SJISHEX[2] = '\x0';

	// 2週目でフラグが1だったら２にしておく
	if ( flag_su == 1 ) { flag_su = 2; }
	// Shift-JISの先頭バイトが見つかればフラグを１に
	if ( (SJIS_CHECK_STR) && flag_su != 1 && flag_su != 2 ){ flag_su = 1; }
	//

		// switch文の開始
		switch (flag_su) {
		// ascii文字だった場合そのまま書きだす
		case 0:
			// Shift_JIS以外のasciiコードならばそのまま書きだす
			// SJISからUTF-8に値渡し
			c_utf8 = c_sjis;
			fputc(c_utf8, fp_utf8);
			break;

			// 1文字目のShift_JISコードを見つけたので保存
		case 1:
			// 1文字目が一致したので先頭１バイトを格納する
			char testHex[8];
			sprintf(testHex, "%02x", (char*)c_sjis);
			search_table[0] = testHex[0];
			search_table[1] = testHex[1];
			search_table[2] = '\x0';

			// もしも1文字目で変換が必要な半角カナ文字等だったらここで変換する
			if (HANKAKU_CHECK_STR) {
			printf("convert: %s ",search_table);

			// 変換テーブルは読み込み専用で開く
			ifstream transtable( "./dat/transtable.dat", std::ios::in );

			// 対象となる文字列が見つかるまでループ
			while ( getline(transtable, lineTrans) ) {
				char scanstr[ 64 ];
				strcpy( scanstr, lineTrans.c_str() );

				// スキャンした文字列中のSJISとUTF8文字列へのポインタ
				char *psjis_kana = scanstr;
				psjis_kana = psjis_kana + 11;

				// 探索文字列の大文字化
				for( int i=0; i<3; i++ ){
				search_table[i] = toupper( search_table[i] );
				}
				// scanstr中のSJIS文字列と一致すればループ脱出
				if ( *psjis_kana == search_table[0] &&
					*(psjis_kana+1) == search_table[1] ) {

				// UTF-8用のバイナリを作成して書きこむ
				char wb1[3] = { scanstr[21], scanstr[22], '\x0' };
				char wb2[3] = { scanstr[23], scanstr[24], '\x0' };
				char wb3[3] = { scanstr[25], scanstr[26], '\x0' };

				printf("to %s%s%s \n",wb1,wb2,wb3);

				//char型文字列から変換
				long	nValue;
				char*	wbEnd;

				nValue = ::strtol(wb1,&wbEnd,16);
				fputc((unsigned int)nValue, fp_utf8);
				nValue = ::strtol(wb2,&wbEnd,16);
				fputc((unsigned int)nValue, fp_utf8);
				nValue = ::strtol(wb3,&wbEnd,16);
				fputc((unsigned int)nValue, fp_utf8);

				}
			}
			// フラグをもとに戻す
			flag_su = 0;
			// 変換テーブルは毎回閉じる
			transtable.close();
			}

			break;

			// 2文字目のShift_JISコードを見つけて変換テーブルに探しに行く
		case 2:
			sprintf(testHex, "%02x", (char*)c_sjis);
			search_table[2] = testHex[0];
			search_table[3] = testHex[1];
			search_table[4] = '\x0';

			// 変換テーブルは読み込み専用で開く
			ifstream transtable( "./dat/transtable.dat", std::ios::in );

			// 対象となる文字列が見つかるまでループ
			while ( getline(transtable, lineTrans) ) {
			char scanstr[ 64 ];
			strcpy( scanstr, lineTrans.c_str() );

			// スキャンした文字列中のSJISとUTF8文字列へのポインタ
			char *psjis = scanstr;
			psjis = psjis + 11;

			// 探索文字列の大文字化
			for( int i=0; i<5; i++ ){
				search_table[i] = toupper( search_table[i] );
			}
			// scanstr中のSJIS文字列と一致すればループ脱出
			if ( *psjis == search_table[0] &&
				*(psjis+1) == search_table[1] &&
				*(psjis+2) == search_table[2] &&
				*(psjis+3) == search_table[3]   ) {

				// UTF-8用のバイナリを作成して書きこむ
				char wb1[3] = { scanstr[21], scanstr[22], '\x0' };
				char wb2[3] = { scanstr[23], scanstr[24], '\x0' };
				char wb3[3] = { scanstr[25], scanstr[26], '\x0' };

				//char型文字列から変換
				long	nValue;
				char*	wbEnd;

				nValue = ::strtol(wb1,&wbEnd,16);
				fputc((unsigned int)nValue, fp_utf8);
				nValue = ::strtol(wb2,&wbEnd,16);
				fputc((unsigned int)nValue, fp_utf8);
				nValue = ::strtol(wb3,&wbEnd,16);
				// 文字「×」の文字コードは「C397__」後半の２文字が無いので飛ばすように設定
				if ( strncmp(wb1 ,"C3" , 2) == 0 || strncmp(wb1 ,"C2" , 2) == 0) {break;}
				fputc((unsigned int)nValue, fp_utf8);
				break;
				}
			}
			// フラグをもとに戻す
			flag_su = 0;
			// 変換テーブルは毎回閉じる
			transtable.close();
			break;
		}// switch文終了
    }
    fclose( fp_sjis );
    fclose( fp_utf8 );
}


// 取得した板一覧ファイルからデータを抽出してレイアウトに反映するメソッド
void JaneClone::SetBoardList(){

	// インスタンスを作る
	ExtractBoardList *ebl = new ExtractBoardList();
	// 板一覧の情報が入ったリストをもらう
	wxArrayString boardListArray = ebl->GetBoardList();
	// GUIにツリーコントロールを反映する
	/*
	for (int i=0;i < boardListArray.size();i++) {
		// ツリー名登録のための文字列
		int treeID;
		// 文字列が入っていなければツリーには入れない
		if (!boardListArray[i].IsEmpty()) {
			// カテゴリフォルダに当たる場合フォルダアイコンとしてツリーに登録
			if (boardListArray[i].Contains(wxT("category:")) == 1) {
				wxTreeItemId i = m_tree_ctrl->AppendItem(m_rootId,boardListArray[i].Remove(0, 9), 0, 0, m_treeData);
				treeID = i;
			}else{
			// そうでなければファイルとしてツリーに登録
				m_tree_ctrl->AppendItem(treeID,boardListArray[i], 1, 1, m_treeData);
			}
		}
	}
	*/
}

// バージョン情報が書かれたダイアログを表示する処理
void JaneClone::OnVersionInfo(wxCommandEvent&)
{
	wxMessageDialog dialog( NULL,
							wxT("Jane Clone Version 1.00 \n\n Copyright(C) 2011 Nantonaku-Shiawase \n\n http://d.hatena.ne.jp/panzer-jagdironscrap1/"),
							wxT("バージョン情報"),
							wxOK|wxICON_INFORMATION);
	dialog.ShowModal();
}




