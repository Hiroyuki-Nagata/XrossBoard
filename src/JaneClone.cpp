/* JaneClone - a text board site viewer for 2ch
 * Copyright (C) 2012 Hiroyuki Nagata
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * Contributor:
 *	Hiroyuki Nagata <newserver002@gmail.com>
 */

// -*- C++ -*- generated by wxGlade 0.6.3 on Tue Nov 01 01:42:24 2011
#include "JaneClone.h"

#if defined(__WXGTK__)
#include"../rc/janeclone.xpm"
#endif

// event table
BEGIN_EVENT_TABLE(JaneClone, wxFrame)
// メニューバー・ポップアップメニューにあるコマンド入力で起動するメソッドのイベントテーブル
EVT_MENU(ID_Quit, JaneClone::OnQuit)
EVT_MENU(ID_GetBoardList, JaneClone::OnGetBoardList)
EVT_MENU(ID_CheckLogDirectory, JaneClone::CheckLogDirectory)
EVT_MENU(ID_GetVersionInfo, JaneClone::OnVersionInfo)
EVT_MENU(ID_OneBoardTabClose, JaneClone::OneBoardTabClose)
EVT_MENU(ID_ExcepSelTabClose, JaneClone::ExcepSelTabClose)
EVT_MENU(ID_AllBoardTabClose, JaneClone::AllBoardTabClose)
EVT_MENU(ID_AllLeftBoardTabClose, JaneClone::AllLeftBoardTabClose)
EVT_MENU(ID_AllRightBoardTabClose, JaneClone::AllRightBoardTabClose)
EVT_MENU(ID_OnOpenBoardByBrowser, JaneClone::OnOpenBoardByBrowser)
EVT_MENU(ID_ReloadOneBoard, JaneClone::ReloadOneBoard)
EVT_MENU(ID_CopyBURLToClipBoard, JaneClone::CopyBURLToClipBoard)
EVT_MENU(ID_CopyBTitleToClipBoard, JaneClone::CopyBTitleToClipBoard)
EVT_MENU(ID_CopyBBothDataToClipBoard, JaneClone::CopyBBothDataToClipBoard)
EVT_MENU(ID_CopyTURLToClipBoard, JaneClone::CopyTURLToClipBoard)
EVT_MENU(ID_CopyTTitleToClipBoard, JaneClone::CopyTTitleToClipBoard)
EVT_MENU(ID_CopyTBothDataToClipBoard, JaneClone::CopyTBothDataToClipBoard)
EVT_MENU(ID_OneThreadTabClose, JaneClone::OneThreadTabClose)
EVT_MENU(ID_ExcepSelThreadTabClose, JaneClone::ExcepSelThreadTabClose)
EVT_MENU(ID_AllThreadTabClose, JaneClone::AllThreadTabClose)
EVT_MENU(ID_AllLeftThreadTabClose, JaneClone::AllLeftThreadTabClose)
EVT_MENU(ID_AllRightThreadTabClose, JaneClone::AllRightThreadTabClose)
EVT_MENU(ID_OnOpenThreadByBrowser, JaneClone::OnOpenThreadByBrowser)
EVT_MENU(ID_SaveDatFile, JaneClone::SaveDatFile)
EVT_MENU(ID_SaveDatFileToClipBoard, JaneClone::SaveDatFileToClipBoard)
EVT_MENU(ID_DeleteDatFile, JaneClone::DeleteDatFile)
EVT_MENU(ID_ReloadThisThread, JaneClone::ReloadThisThread)
// ツリーコントロールのイベント
EVT_TREE_SEL_CHANGED(wxID_ANY, JaneClone::OnGetBoardInfo)
// 板一覧ノートブックで右クリックされた時の処理
EVT_AUINOTEBOOK_TAB_RIGHT_DOWN(ID_BoardNoteBook, JaneClone::OnRightClickBoardNoteBook)
// スレッド一覧ノートブックで右クリックされた時の処理
EVT_AUINOTEBOOK_TAB_RIGHT_DOWN(ID_ThreadNoteBook, JaneClone::OnRightClickThreadNoteBook)
// スレッド一覧ノートブックで、タブが消される前の処理
EVT_AUINOTEBOOK_PAGE_CLOSE(ID_ThreadNoteBook, JaneClone::OnAboutCloseThreadNoteBook)
// AuiNotebookのタブを変更した時の処理
EVT_AUINOTEBOOK_PAGE_CHANGING(wxID_ANY, JaneClone::OnChangedTab)
// スレッド一覧リストでのクリック
EVT_LIST_ITEM_SELECTED(wxID_ANY, JaneClone::OnLeftClickAtListCtrl)
// 終了前処理
EVT_CLOSE(JaneClone::OnCloseWindow)
// wxHtmlWindow上でのイベント処理
EVT_HTML_CELL_HOVER(wxID_ANY, JaneClone::OnCellHover)
EVT_HTML_CELL_CLICKED(wxID_ANY, JaneClone::OnCellClicked)
EVT_HTML_LINK_CLICKED(wxID_ANY, JaneClone::OnLinkClicked)
END_EVENT_TABLE()

JaneClone::JaneClone(wxWindow* parent, int id, const wxString& title, const wxPoint& pos, const wxSize& size, long style):
wxFrame(parent, id, title, pos, size, wxDEFAULT_FRAME_STYLE)
{
	// アイコンの設定
#if defined(__WXMSW__)
	SetIcon(wxICON(wxicon));
#endif
#if defined(__WXGTK__)
	SetIcon(wxICON(janeclone));
#endif

	/**
	 * 必要なwxWindowを宣言する
	 */
	// 板一覧を取得してツリー表示
	m_tree_ctrl = new wxTreeCtrl(this, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);

	// 検索バー
	m_search_ctrl = new wxSearchCtrl((wxWindow*)this, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxTE_PROCESS_ENTER);
	// URL入力欄
	m_url_input_panel = new wxPanel(this, wxID_ANY);
	m_url_input = new wxTextCtrl(m_url_input_panel, wxID_ANY, m_url_text, wxDefaultPosition, wxDefaultSize);
	m_url_input_button = new wxBitmapButton(m_url_input_panel, wxID_ANY, wxBitmap(wxT("rc/go-next.png"), wxBITMAP_TYPE_ANY));
	// ログ出力ウィンドウ
	m_logCtrl = new wxTextCtrl(this, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxTE_MULTILINE | wxTE_READONLY);
	wxFont font;
	font.SetNativeFontInfoUserDesc(wxT("MS PGothic 12 CP932"));
	wxTextAttr attr;
	attr.SetFont(font);
	m_logCtrl->SetDefaultStyle(attr);

	*m_logCtrl << wxT("(ヽ´ん`)…デバッグ用画面…\n");
	// ステータスバー設置
	this->CreateStatusBar(2);

	// わかりやすい画像つき各種処理ボタン

	// 各種GUI設定を行う
	SetJaneCloneManuBar();
	SetProperties();
	DoLayout();

	// ユーザーが前回までに見ていた板一覧タブとスレッド一覧タブをセットする
	SetPreviousUserLookedTab();
	SetStatusText(wxT(" 完了"));
	*m_logCtrl << wxT("(ヽ´ん`)…レイアウト設定終わりです…\n");
}
/**
 * SetJaneCloneManuBar
 * メニューバーの設定を行う
 */
void JaneClone::SetJaneCloneManuBar() {
	/*
	 * メニューバーの設置
	 */
	wxMenuBar *menuBar = new wxMenuBar;
	/**
	 * ファイル部分
	 */
	wxMenu *menu1 = new wxMenu;
	menu1->AppendSeparator();
	wxMenu *closeT = new wxMenu;
	closeT->Append(wxID_ANY, wxT("最後に閉じたスレを開く"));
	closeT->AppendSeparator();
	menu1->AppendSubMenu(closeT, wxT("最近閉じたスレ"));
	wxMenu *closeRec = new wxMenu;
	closeRec->Append(wxID_ANY, wxT("最後に閉じた板を開く"));
	closeRec->AppendSeparator();
	menu1->AppendSubMenu(closeRec, wxT("最近閉じた板"));
	menu1->AppendSeparator();
	menu1->Append(ID_Restart, wxT("再起動"));
	menu1->Append(ID_Quit, wxT("終了"));
	/**
	 * 表示部分
	 */
	wxMenu *menu2 = new wxMenu;
	menu2->Append(wxID_ANY, wxT("表示～"));
	/**
	 * 板覧部分
	 */
	wxMenu *menu3 = new wxMenu;
	menu3->Append(ID_GetBoardList, wxT("板一覧の更新"));
	menu3->AppendSeparator();
	menu3->Append(wxID_ANY, wxT("お気に入りを板として開く"));
	menu3->Append(wxID_ANY, wxT("ログ一覧を開く"));
	menu3->Append(wxID_ANY, wxT("開いているスレッドを板として開く"));
	menu3->Append(wxID_ANY, wxT("最近読み込んだスレッド"));
	menu3->Append(wxID_ANY, wxT("最近書き込んだスレッド"));
	menu3->AppendSeparator();
	menu3->Append(ID_CheckLogDirectory, wxT("ログフォルダのチェック"));
	menu3->AppendSeparator();
	menu3->Append(wxID_ANY, wxT("すべての板のインデックスを再構築"));
	menu3->Append(wxID_ANY, wxT("ログの再構築"));
	menu3->AppendSeparator();
	menu3->Append(wxID_ANY, wxT("ログ一覧制限変更"));
	menu3->Append(wxID_ANY, wxT("ログ一覧から取り込む"));
	menu3->AppendSeparator();
	menu3->Append(wxID_ANY, wxT("新規板登録"));
	/**
	 * スレ覧部分
	 */
	wxMenu *menu4 = new wxMenu;
	wxMenu *closeB = new wxMenu;
	closeB->Append(ID_OneBoardTabClose, wxT("現在の板を閉じる"));
	closeB->AppendSeparator();
	closeB->Append(ID_ExcepSelTabClose, wxT("選択されていない板を閉じる"));
	closeB->Append(ID_AllBoardTabClose, wxT("すべてのタブを閉じる"));
	closeB->Append(ID_AllLeftBoardTabClose, wxT("これより左を閉じる"));
	closeB->Append(ID_AllRightBoardTabClose, wxT("これより右を閉じる"));
	menu4->AppendSubMenu(closeB, wxT("閉じる"));
	menu4->AppendSeparator();
	wxMenu *open = new wxMenu;
	open->Append(wxID_ANY, wxT("新着をすべて開く"));
	open->Append(wxID_ANY, wxT("お気に入りの新着をすべて開く"));
	open->Append(wxID_ANY, wxT("新着スレッドをすべて開く"));
	open->AppendSeparator();
	open->Append(wxID_ANY, wxT("新着のあるスレッドを一件開く"));
	open->AppendSeparator();
	open->Append(wxID_ANY, wxT("新しいタブで開く"));
	open->Append(wxID_ANY, wxT("今のタブで開く"));
	open->Append(wxID_ANY, wxT("バックグラウンドで開く"));
	menu4->AppendSubMenu(open, wxT("開く"));
	menu4->AppendSeparator();
	menu4->Append(wxID_ANY, wxT("選択中のスレを閉じる"));
	menu4->AppendSeparator();
	menu4->Append(wxID_ANY, wxT("選択中のスレをタブロック"));
	menu4->Append(wxID_ANY, wxT("既読にする"));
	menu4->Append(wxID_ANY, wxT("印を付ける"));
	menu4->Append(wxID_ANY, wxT("お気に入りに追加"));
	menu4->Append(wxID_ANY, wxT("お気に入りを削除"));
	menu4->AppendSeparator();
	menu4->Append(ID_ReloadOneBoard, wxT("スレ一覧更新"));
	menu4->Append(wxID_ANY, wxT("すべてのタブのスレ一覧更新"));
	menu4->Append(wxID_ANY, wxT("板移転の追尾"));
	menu4->AppendSeparator();
	menu4->Append(wxID_ANY, wxT("スレッド新規作成"));
	menu4->AppendSeparator();
	menu4->Append(ID_OnOpenBoardByBrowser, wxT("ブラウザで開く"));
	menu4->Append(wxID_ANY, wxT("看板を見る"));
	menu4->AppendSeparator();
	wxMenu *selectCopy = new wxMenu;
	selectCopy->Append(wxID_ANY, wxT("datをクリップボードにコピー"));
	menu4->AppendSubMenu(selectCopy, wxT("選択中のログをコピー"));
	wxMenu *copy = new wxMenu;
	copy->Append(ID_CopyBURLToClipBoard, wxT("URLをコピー"));
	copy->Append(ID_CopyBTitleToClipBoard, wxT("タイトルをコピー"));
	copy->Append(ID_CopyBBothDataToClipBoard, wxT("タイトルとURLをコピー"));
	menu4->AppendSubMenu(copy, wxT("コピー"));
	menu4->AppendSeparator();
	wxMenu *deleteLog = new wxMenu;
	deleteLog->Append(wxID_ANY, wxT("選択中のログを削除"));
	deleteLog->Append(wxID_ANY, wxT("すべてのログを削除"));
	deleteLog->Append(wxID_ANY, wxT("お気に入り以外のログを削除"));
	menu4->AppendSubMenu(deleteLog, wxT("ログ削除"));
	menu4->AppendSeparator();
	menu4->Append(wxID_ANY, wxT("このスレをチェック"));
	menu4->AppendSeparator();
	wxMenu *abone = new wxMenu;
	abone->Append(wxID_ANY, wxT("スレッドあぼ～ん"));
	abone->Append(wxID_ANY, wxT("透明スレッドあぼ～ん"));
	abone->Append(wxID_ANY, wxT("あぼ～ん・チェックを解除"));
	menu4->AppendSubMenu(abone, wxT("あぼ～ん"));
	menu4->AppendSeparator();
	wxMenu *sort = new wxMenu;
	sort->Append(wxID_ANY, wxT("1 !"));
	sort->Append(wxID_ANY, wxT("2 番号"));
	sort->Append(wxID_ANY, wxT("3 タイトル"));
	sort->Append(wxID_ANY, wxT("4 レス"));
	sort->Append(wxID_ANY, wxT("5 取得"));
	sort->Append(wxID_ANY, wxT("6 新着"));
	sort->Append(wxID_ANY, wxT("7 最終取得"));
	sort->Append(wxID_ANY, wxT("8 最終書込"));
	sort->Append(wxID_ANY, wxT("9 Since"));
	sort->Append(wxID_ANY, wxT("0 板"));
	sort->Append(wxID_ANY, wxT("a 勢い"));
	sort->Append(wxID_ANY, wxT("b 増レス"));
	sort->AppendSeparator();
	sort->AppendCheckItem(wxID_ANY, wxT("開いているスレを上へソート"));
	sort->AppendCheckItem(wxID_ANY, wxT("重要スレを上へソート"));
	menu4->AppendSubMenu(sort, wxT("ソート"));
	wxMenu *aboneB = new wxMenu;
	aboneB->AppendRadioItem(wxID_ANY, wxT("透明"));
	aboneB->AppendRadioItem(wxID_ANY, wxT("標準"));
	aboneB->AppendRadioItem(wxID_ANY, wxT("あぼ～ん無効"));
	aboneB->AppendRadioItem(wxID_ANY, wxT("あぼ～んのみ"));
	aboneB->AppendRadioItem(wxID_ANY, wxT("重要スレのみ"));
	menu4->AppendSubMenu(aboneB, wxT("スレッドあぼ～んの表示変更"));
	menu4->AppendSeparator();
	menu4->Append(wxID_ANY, wxT("過去ログ非表示"));
	/**
	 * スレッド部分
	 */
	wxMenu *menu5 = new wxMenu;
	wxMenu *closeTh = new wxMenu;
	closeTh->Append(ID_OneThreadTabClose, wxT("選択中のタブを閉じる"));
	closeTh->Append(wxID_ANY, wxT("未読として閉じる"));
	closeTh->AppendSeparator();
	closeTh->Append(ID_ExcepSelThreadTabClose, wxT("選択されていないタブを閉じる"));
	closeTh->Append(ID_AllThreadTabClose, wxT("すべてのタブを閉じる"));
	closeTh->Append(ID_AllLeftThreadTabClose, wxT("これより左を閉じる"));
	closeTh->Append(ID_AllRightThreadTabClose, wxT("これより右を閉じる"));
	closeTh->AppendSeparator();
	closeTh->Append(wxID_ANY, wxT("新着なしのタブを閉じる"));
	closeTh->Append(wxID_ANY, wxT("dat落ちのタブを閉じる"));
	menu5->AppendSubMenu(closeTh, wxT("閉じる"));
	menu5->AppendSeparator();
	wxMenu *tabLock = new wxMenu;
	tabLock->Append(wxID_ANY, wxT("このタブをロックする"));
	tabLock->Append(wxID_ANY, wxT("すべてのタブをロックする"));
	tabLock->Append(wxID_ANY, wxT("これより左をロックする"));
	tabLock->Append(wxID_ANY, wxT("これより右をロックする"));
	menu5->AppendSubMenu(tabLock, wxT("タブロック"));
	menu5->AppendSeparator();
	menu5->Append(wxID_ANY, wxT("次スレ候補検索"));
	menu5->Append(wxID_ANY, wxT("次スレ候補を開く"));
	menu5->AppendSeparator();
	menu5->Append(wxID_ANY, wxT("ヒストリー検索"));
	menu5->AppendSeparator();
	menu5->Append(wxID_ANY, wxT("印を付ける"));
	wxMenu *addFav = new wxMenu;
	addFav->Append(wxID_ANY, wxT("「お気に入り」に追加"));
	addFav->AppendSeparator();
	addFav->Append(wxID_ANY, wxT("「リンク」に追加"));
	menu5->AppendSubMenu(addFav, wxT("お気に入りに追加"));
	menu5->Append(wxID_ANY, wxT("お気に入りを削除"));
	menu5->AppendSeparator();
	menu5->Append(wxID_ANY, wxT("強制過去ログ化"));
	menu5->AppendSeparator();
	wxMenu *move = new wxMenu;
	move->Append(wxID_ANY, wxT("戻る"));
	move->Append(wxID_ANY, wxT("進む"));
	move->AppendSeparator();
	move->Append(wxID_ANY, wxT("閉じた付近に戻る"));
	move->Append(wxID_ANY, wxT("新着までスクロール"));
	move->Append(wxID_ANY, wxT("次のレス↓"));
	move->Append(wxID_ANY, wxT("前のレス↑"));
	move->AppendSeparator();
	move->Append(wxID_ANY, wxT("指定レス番号にジャンプ"));
	menu5->AppendSubMenu(move, wxT("移動"));
	menu5->AppendSeparator();
	menu5->Append(wxID_ANY, wxT("新着チェック"));
	menu5->Append(wxID_ANY, wxT("すべてのタブの新着チェック"));
	menu5->Append(wxID_ANY, wxT("すべてのタブの更新チェック"));
	menu5->Append(wxID_ANY, wxT("中止"));
	menu5->Append(wxID_ANY, wxT("レス"));
	menu5->AppendSeparator();
	menu5->Append(ID_OnOpenThreadByBrowser, wxT("ブラウザで開く"));
	menu5->AppendSeparator();
	wxMenu *broadcast = new wxMenu;
	broadcast->Append(wxID_ANY, wxT("オートリロード"));
	broadcast->Append(wxID_ANY, wxT("オートスクロール"));
	broadcast->Append(wxID_ANY, wxT("オートリロード・スクロール"));
	menu5->AppendSubMenu(broadcast, wxT("実況支援"));
	menu5->AppendSeparator();
	wxMenu *copyMenu5 = new wxMenu;
	copyMenu5->Append(ID_CopyTURLToClipBoard, wxT("URLをコピー"));
	copyMenu5->Append(ID_CopyTTitleToClipBoard, wxT("タイトルをコピー"));
	copyMenu5->Append(ID_CopyTBothDataToClipBoard, wxT("タイトルとURLをコピー"));
	menu5->AppendSubMenu(copyMenu5, wxT("コピー"));
	menu5->AppendSeparator();
	menu5->Append(wxID_ANY, wxT("この板を開く"));
	menu5->Append(wxID_ANY, wxT("この板の看板を見る"));
	menu5->AppendSeparator();
	wxMenu *saveLog = new wxMenu;
	saveLog->Append(ID_SaveDatFile, wxT("datを名前を付けて保存"));
	saveLog->Append(ID_SaveDatFileToClipBoard, wxT("datをクリップボードにコピー"));
	menu5->AppendSubMenu(saveLog, wxT("このログを保存"));
	menu5->Append(ID_DeleteDatFile, wxT("このログを削除"));
	menu5->Append(ID_ReloadThisThread, wxT("再読み込み"));
	menu5->AppendSeparator();
	wxMenu *iReadHere = new wxMenu;
	iReadHere->Append(wxID_ANY, wxT("この辺まで読んだ"));
	iReadHere->Append(wxID_ANY, wxT("最後まで読んだ"));
	iReadHere->Append(wxID_ANY, wxT("「ここまで読んだ」にジャンプ"));
	iReadHere->Append(wxID_ANY, wxT("「ここまで読んだ」を解除"));
	menu5->AppendSubMenu(iReadHere, wxT("ここまで読んだ"));
	wxMenu *chkResponse = new wxMenu;
	chkResponse->Append(wxID_ANY, wxT("レスのチェックをすべて解除"));
	menu5->AppendSubMenu(chkResponse, wxT("レスのチェック"));
	menu5->AppendSeparator();
	wxMenu *changeLocalAbone = new wxMenu;
	changeLocalAbone->AppendRadioItem(wxID_ANY, wxT("透明"));
	changeLocalAbone->AppendRadioItem(wxID_ANY, wxT("標準"));
	changeLocalAbone->AppendRadioItem(wxID_ANY, wxT("ポップアップ"));
	changeLocalAbone->AppendRadioItem(wxID_ANY, wxT("あぼ～ん無効"));
	changeLocalAbone->AppendRadioItem(wxID_ANY, wxT("あぼ～んのみ"));
	changeLocalAbone->AppendRadioItem(wxID_ANY, wxT("自分書込のみ"));
	changeLocalAbone->AppendRadioItem(wxID_ANY, wxT("自分返信のみ"));
	menu5->AppendSubMenu(changeLocalAbone, wxT("ローカルあぼ～ん表示の変更"));
	wxMenu *extractRedRes = new wxMenu;
	extractRedRes->Append(wxID_ANY, wxT("赤レス抽出"));
	extractRedRes->Append(wxID_ANY, wxT("被参照レス抽出"));
	extractRedRes->AppendSeparator();
	extractRedRes->Append(wxID_ANY, wxT("赤レスフィルタ"));
	extractRedRes->Append(wxID_ANY, wxT("被参照レス抽出フィルタ"));
	menu5->AppendSubMenu(extractRedRes, wxT("赤レス抽出"));

	/**
	 * お気に入り部分
	 */
	wxMenu *menu6 = new wxMenu;

	// ！ここはお気に入りスレッドを動的に確保する！

	/**
	 * 検索部分
	 */
	wxMenu *menu7 = new wxMenu;
	menu7->Append(wxID_ANY, wxT("検索"));
	menu7->Append(wxID_ANY, wxT("↓検索"));
	menu7->Append(wxID_ANY, wxT("↑検索"));
	menu7->AppendSeparator();
	menu7->Append(wxID_ANY, wxT("レス抽出"));
	menu7->AppendSeparator();
	menu7->Append(wxID_ANY, wxT("スレのツリー形式表示"));
	menu7->Append(wxID_ANY, wxT("スレのアウトライン表示"));
	menu7->AppendSeparator();
	menu7->Append(wxID_ANY, wxT("スレ絞込み"));
	menu7->Append(wxID_ANY, wxT("スレ絞込み結果クリア"));
	menu7->Append(wxID_ANY, wxT("ログから検索"));
	menu7->AppendSeparator();
	menu7->Append(wxID_ANY, wxT("スレッドタイトル検索"));
	menu7->Append(wxID_ANY, wxT("2chのURLにジャンプ"));
	menu7->AppendSeparator();
	menu7->Append(wxID_ANY, wxT("検索履歴削除"));
	/**
	 * ウィンドウ部分
	 */
	wxMenu *menu8 = new wxMenu;
	menu8->Append(wxID_ANY, wxT("閉じる"));
	menu8->AppendSeparator();
	menu8->Append(wxID_ANY, wxT("次のタブ"));
	menu8->Append(wxID_ANY, wxT("前のタブ"));
	menu8->AppendSeparator();
	menu8->Append(wxID_ANY, wxT("重ねて表示"));
	menu8->Append(wxID_ANY, wxT("左右に並べて表示"));
	menu8->Append(wxID_ANY, wxT("上下に並べて表示"));
	menu8->Append(wxID_ANY, wxT("すべて元のサイズに戻す"));
	menu8->Append(wxID_ANY, wxT("すべて最大化"));
	menu8->AppendSeparator();
	menu8->Append(wxID_ANY, wxT("最小化"));
	menu8->AppendSeparator();

	// ！ここは開いているスレを動的に確保する！

	/**
	 * ツール部分
	 */
	wxMenu *menu9 = new wxMenu;
	menu9->Append(wxID_ANY, wxT("更新チェック"));
	menu9->AppendSeparator();
	wxMenu *image = new wxMenu;
	image->Append(wxID_ANY, wxT("マウスオーバーで画像を開く"));
	image->Append(wxID_ANY, wxT("クリップボード監視"));
	image->AppendSeparator();
	image->Append(wxID_ANY, wxT("キャッシュ一覧"));
	menu9->AppendSubMenu(image, wxT("画像"));
	wxMenu *memo = new wxMenu;
	memo->Append(wxID_ANY, wxT("名前履歴消去"));
	memo->Append(wxID_ANY, wxT("メール履歴消去"));
	memo->AppendSeparator();
	memo->Append(wxID_ANY, wxT("次のメモ"));
	memo->Append(wxID_ANY, wxT("前のメモ"));
	memo->Append(wxID_ANY, wxT("名前をつけて保存"));
	memo->Append(wxID_ANY, wxT("ファイルを開く"));
	memo->Append(wxID_ANY, wxT("メモをクリア"));
	memo->Append(wxID_ANY, wxT("AA入力支援"));
	memo->Append(wxID_ANY, wxT("一つ前のレスを貼り付け"));
	memo->AppendSeparator();
	memo->Append(wxID_ANY, wxT("メモ欄の内容で書き込む"));
	menu9->AppendSubMenu(memo, wxT("メモ"));
	menu9->AppendSeparator();
	menu9->AppendCheckItem(wxID_ANY, wxT("サウンド"));
	menu9->AppendSeparator();
	menu9->Append(wxID_ANY, wxT("ビューア設定"));
	menu9->Append(wxID_ANY, wxT("設定"));
	/**
	 * ヘルプ部分
	 */
	wxMenu *menu10 = new wxMenu;
	menu10->Append(wxID_ANY, wxT("ヘルプ"));
	menu10->AppendSeparator();
	menu10->Append(wxID_ANY, wxT("JaneClone公式サイトをブラウザで開く"));
	menu10->AppendSeparator();
	menu10->Append(wxID_ANY, wxT("2ちゃんねるビューア●に登録"));
	menu10->AppendSeparator();
	menu10->Append(wxID_ANY, wxT("アップデートチェック"));
	menu10->AppendSeparator();
	menu10->Append(wxID_ANY, wxT("バグレポート"));
	menu10->Append(ID_GetVersionInfo, wxT("バージョン情報を開く"));

	menuBar->Append(menu1, wxT("ファイル"));
	menuBar->Append(menu2, wxT("表示"));
	menuBar->Append(menu3, wxT("板覧"));
	menuBar->Append(menu4, wxT("スレ覧"));
	menuBar->Append(menu5, wxT("スレッド"));
	menuBar->Append(menu6, wxT("お気に入り"));
	menuBar->Append(menu7, wxT("検索"));
	menuBar->Append(menu8, wxT("ウィンドウ"));
	menuBar->Append(menu9, wxT("ツール"));
	menuBar->Append(menu10, wxT("ヘルプ"));

	// Linuxではファイルごとクリップボードにコピーすることができない
#ifndef __WXMSW__
	menuBar->Enable(ID_SaveDatFileToClipBoard, false);
#endif

	SetMenuBar(menuBar);
	/**
	 * メニューバー設置終わり
	 */
}
/**
 * SetProperties
 * 前回からのデータ引継ぎ等の処理を行う。
 */
void JaneClone::SetProperties() {
	// wxGladeによる自動生成
	SetTitle(_("JaneClone"));
	SetSize(wxSize(960, 640));

	// イメージリストにアイコンを登録する
	wxImageList *treeImage = new wxImageList(16, 16);
	wxBitmap idx1(wxT("rc/folder.png"), wxBITMAP_TYPE_PNG);
	treeImage->Add(idx1);
	wxBitmap idx2(wxT("rc/text-html.png"), wxBITMAP_TYPE_PNG);
	treeImage->Add(idx2);
	m_tree_ctrl->AssignImageList(treeImage);

	// 板一覧情報のツリーコントロール
	m_treeData = new wxTreeItemData();
	m_rootId = m_tree_ctrl->AddRoot(wxT("2ch板一覧"), 0, 0, m_treeData);

	// カレントディレクトリを設定
	wxDir dir(wxGetCwd());
	// datフォルダ、propフォルダが存在するか確認。無ければ確認＆フォルダを作成
	if (!dir.Exists(wxT("./dat/"))) {
		::wxMkdir(wxT("./dat/"));
	}

	if (!dir.Exists(wxT("./prop/"))) {
		wxMkdir(wxT("./prop/"));
	}
	// 設定ファイルの準備をする
	wxString configFile = wxGetCwd();
#ifdef __WXMSW__
	// Windowsではパスの区切りは"\"
	configFile += wxT("\\prop\\");
#else
	// Linuxではパスの区切りは"/"
	configFile += wxT("/prop/");
#endif
	configFile += APP_CONFIG_FILE;
	config = new wxFileConfig(wxT("JaneClone"), wxEmptyString, configFile,
			wxEmptyString, wxCONFIG_USE_LOCAL_FILE);

	// metakitの初期化を行う
	MetakitAccessor* metakitAccessor = new MetakitAccessor();
	delete metakitAccessor;

	// もしMetakit上に板一覧情報が存在するならば板一覧設定に飛ぶ
	if (MetakitAccessor::TableHasView(wxT("BOARD_INFO"))) {
		SetBoardList();
	}
	// アプリ上部URL入力欄の画像つきボタンのサイズ調整
	m_url_input_button->SetSize(m_url_input_button->GetBestSize());
	// アプリ上部URL入力欄のフォント調整
	m_url_input->SetFont(wxFont(12, wxDEFAULT, wxNORMAL, wxNORMAL, 0, wxT("")));

	// ノートブックのサイズ調整
	wxSize client_size = GetClientSize();

	// 板名のツリーコントロールをクリックした場合表示されるwxNoteBook
	boardNoteBook = new wxAuiNotebook(this, ID_BoardNoteBook, wxPoint(
			client_size.x, client_size.y), wxDefaultSize,
			wxAUI_NB_DEFAULT_STYLE);

	// 板名のツリーコントロールをクリックした場合表示されるwxNoteBook
	threadNoteBook = new wxAuiNotebook(this, ID_ThreadNoteBook, wxPoint(
			client_size.x, client_size.y), wxDefaultSize,
			wxAUI_NB_DEFAULT_STYLE);
}
/**
 * DoLayout
 * ユーザーが触る前のアプリのレイアウトを設定する
 * 前回の起動時にレイアウトに変更があった場合はそれを反映する
 */
void JaneClone::DoLayout() {
	// アプリ上部、URL入力欄のレイアウトを設定する
	wxBoxSizer* url_sizer = new wxBoxSizer(wxHORIZONTAL);
	url_sizer->Add(m_url_input, 1, wxEXPAND, 0);
	url_sizer->Add(m_url_input_button, 0, 0, 0);
	m_url_input_panel->SetSizer(url_sizer);

	// Auiマネージャーがどのフレームを管理するか示す
	m_mgr.SetManagedWindow(this);
	// それぞれのペインの情報を設定する
	SetJaneCloneAuiPaneInfo();
	// Auiマネージャーの設定を反映する
	m_mgr.Update();
	// 設定ファイルからレイアウト情報を読み取る
	wxString perspective;
	config->Read(wxT("Perspective"), &perspective, wxEmptyString);
	m_mgr.LoadPerspective((const wxString) perspective, true);

	int x, y;
	config->Read(wxT("FrameX"), &x, 640);
	config->Read(wxT("FrameY"), &y, 480);
	this->SetSize(x, y);

	int px, py;
	config->Read(wxT("FramePx"), &px, 0);
	config->Read(wxT("FramePy"), &py, 0);
	this->Move(px, py);

	// ウィンドウの最大化情報
	bool isMaximized;
	config->Read(wxT("IsMaximized"), &isMaximized, false);
	this->Maximize(isMaximized);

	// 初期設定はこのLayout()が呼ばれる前に行わなくてはいけない
	Layout();
	// end wxGlade
}
/**
 * SetJaneCloneAuiPaneInfo
 * AuiManagerのPaneInfoを設定する
 */
void JaneClone::SetJaneCloneAuiPaneInfo() {
	// 上部・検索バーを設定する
	wxAuiPaneInfo search;
	search.Name(wxT("searchbar"));
	search.Caption(wxT("検索バー"));
	search.Top();
	search.CloseButton(false);

	// 上部・URL入力欄を設定する
	wxAuiPaneInfo url;
	url.Name(wxT("urlbar"));
	url.MinSize(wxSize(0, 16));
	url.Caption(wxT("url"));
	url.Top();
	url.CloseButton(false);

	// 左側・板一覧のツリーコントロールを設定する
	wxAuiPaneInfo boardTree;
	boardTree.Name(wxT("boardTree"));
	boardTree.Caption(wxT("板一覧"));
	boardTree.Left();
	boardTree.CloseButton(false);
	boardTree.BestSize(100, 300);

	// 左側下部・ログ出力ウィンドウを設定する
	wxAuiPaneInfo logWindow;
	logWindow.Name(wxT("logWindow"));
	logWindow.Caption(wxT("ログ出力画面"));
	logWindow.Left();
	logWindow.CloseButton(false);
	logWindow.MaxSize(20, 20);

	// 右側上部・板一覧のノートブックとスレッド一覧リストが載ったウィンドウ
	wxAuiPaneInfo boardListThreadListInfo;
	boardListThreadListInfo.Name(wxT("boardListThreadListInfo"));
	boardListThreadListInfo.Caption(wxT("スレッド一覧"));
	boardListThreadListInfo.Right();
	boardListThreadListInfo.Center();
	boardListThreadListInfo.CloseButton(false);
	boardListThreadListInfo.BestSize(400, 400);

	// 右側下部・スレッド一覧タブとスレ表示画面が載ったウィンドウ
	wxAuiPaneInfo threadTabThreadContentInfo;
	threadTabThreadContentInfo.Name(wxT("threadTabThreadContentInfo"));
	threadTabThreadContentInfo.Caption(wxT("開いているスレ"));
	threadTabThreadContentInfo.Right();
	threadTabThreadContentInfo.Center();
	threadTabThreadContentInfo.CloseButton(false);
	threadTabThreadContentInfo.BestSize(400, 400);

	// Addの順番と反映がLinuxとWindowsで逆なので、順番をifdefで設定する
#ifdef __WXMSW__
	m_mgr.AddPane(m_search_ctrl, search);
	m_mgr.AddPane(m_url_input_panel, url);
	m_mgr.AddPane(m_tree_ctrl, boardTree);
	m_mgr.AddPane(m_logCtrl, logWindow);
	m_mgr.AddPane(boardNoteBook, boardListThreadListInfo);
	m_mgr.AddPane(threadNoteBook, threadTabThreadContentInfo);
#else
	m_mgr.AddPane(m_url_input_panel, url);
	m_mgr.AddPane(m_search_ctrl, search);
	m_mgr.AddPane(m_logCtrl, logWindow);
	m_mgr.AddPane(m_tree_ctrl, boardTree);
	m_mgr.AddPane(threadNoteBook, threadTabThreadContentInfo);
	m_mgr.AddPane(boardNoteBook, boardListThreadListInfo);
#endif

}
/**
 * SetPreviousUserLookedTab
 * ユーザーが前回までに見ていた板一覧タブとスレッド一覧タブをセットする
 */
void JaneClone::SetPreviousUserLookedTab() {

	wxArrayString userLookedBoardList = MetakitAccessor::GetUserLookedBoardList();

	for (unsigned int i = 0; i < userLookedBoardList.GetCount(); i++) {

		wxString boardName = userLookedBoardList[i];

		// 板名に対応したURLを取ってくる
		URLvsBoardName hash = retainHash[boardName];
		wxString boardNameAscii = hash.boardNameAscii;
		wxString outputPath = wxT("./dat/") + boardNameAscii + wxT("/")
				+ boardNameAscii + wxT(".dat");

		// 板一覧タブをセットする
		SetThreadListItemNew(boardName, outputPath, (const size_t) i);
	}

	wxArrayString userLookedThreadList = MetakitAccessor::GetUserLookedThreadList();

	for (unsigned int i = 0; i < userLookedThreadList.GetCount(); i+= 3) {

		wxString title = userLookedThreadList[i];
		wxString origNumber = userLookedThreadList[i+1];
		wxString boardNameAscii = userLookedThreadList[i+2];

		// ファイルパスの組み立てとファイルの有無確認
		wxString threadContentPath = JaneCloneUtil::AssembleFilePath(boardNameAscii, origNumber);

		// ファイルの有無確認
		if (!wxFile::Exists(threadContentPath)) {
			// 無ければ警告を出して次へ
			wxMessageBox(wxT("前回読み込んでいたdatファイルの読み出しに失敗しました"));
			continue;
		}

		// スレッドの内容をノートブックに反映する
		SetThreadContentToNoteBook(threadContentPath, origNumber, title);
		// ノートブックに登録されたスレッド情報をハッシュに登録する
		ThreadInfo info;
		info.origNumber = origNumber;
		info.boardNameAscii = boardNameAscii;
		tiHash[title] = info;
	}
}
/**
 * デストラクタ
 */
JaneClone::~JaneClone() {
	// Auiマネージャーを削除する
	m_mgr.UnInit();
	delete config;
}
/**
 * JaneCloneを終了させる
 */
void JaneClone::OnQuit(wxCommandEvent&) {

	// ツリーコントロールをデリートしてやらないとセグる
	delete m_tree_ctrl;
	// Auiマネージャーを削除する
	m_mgr.UnInit();

	Close(true);
}
/**
 * 板一覧のツリーがクリックされたときに起きるイベント
 */
void JaneClone::OnGetBoardInfo(wxTreeEvent& event) {
	// 選択されたTreeItemIdのインスタンス
	wxTreeItemId pushedTree = event.GetItem();

	// もし選択されたツリーが板名だったら(※TreeItemに子要素が無かったら)
	if (!m_tree_ctrl->ItemHasChildren(pushedTree)) {
		// 板名をwxStringで取得する
		wxString boardName(m_tree_ctrl->GetItemText(pushedTree));
		// URLを保持する文字列
		wxString boardURL;
		// サーバー名を保持する文字列
		wxString boardNameAscii;

		// 板名に対応したURLを取ってくる
		URLvsBoardName hash = retainHash[boardName];
		boardNameAscii = hash.boardNameAscii;
		boardURL = hash.boardURL;

		// 板一覧のツリーをクリックして、それをノートブックに反映するメソッド
		SetBoardNameToNoteBook(boardName, boardURL, boardNameAscii);
	}
}
/**
 * 板一覧のツリーをクリックして、それをノートブックに反映するメソッド
 */
void JaneClone::SetBoardNameToNoteBook(wxString& boardName, wxString& boardURL,
		wxString& boardNameAscii) {

	// スレ一覧をダウンロードする
	SocketCommunication* socketCommunication = new SocketCommunication();
	socketCommunication->SetLogWindow(m_logCtrl);
	wxString outputPath = socketCommunication->DownloadThreadList(boardName, boardURL, boardNameAscii);
	delete socketCommunication;

	// 新規にセットされる板名かどうかのフラグを用意する
	bool itIsNewBoardName = true;
	// 次に選択されるべきタブのページ数を格納する変数
	size_t selectedPage = 0;

	// ユーザーが開いているタブの板名を調べる
	for (unsigned int i = 0; i < boardNoteBook->GetPageCount(); i++) {
		if (boardName.Cmp(boardNoteBook->GetPageText(i)) == 0) {
			itIsNewBoardName = false;
			selectedPage = i;
			break;
		}
	}

	if (itIsNewBoardName) {
		// もし新規のダウンロードだった場合、選択されるべきページを指定
		selectedPage = boardNoteBook->GetPageCount();
		SetThreadListItemNew((const wxString) boardName,
				(const wxString) outputPath, (const size_t) selectedPage);
	} else {
		// 更新処理の場合、選択されるべきページはi
		SetThreadListItemUpdate((const wxString) boardName,
				(const wxString) outputPath, (const size_t) selectedPage);
	}
}
/**
 * ノートブックに、新規にダウンロードされたスレッド一覧情報を反映するメソッド
 */
void JaneClone::SetThreadListItemNew(const wxString boardName,
		const wxString outputPath, const size_t selectedPage) {

	// ノートブックの変更中はノートブックに触れないようにする
	boardNoteBook->Freeze();
	// Hashに格納する板名タブのオブジェクトのインスタンスを準備する
	VirtualBoardListCtrl* vbListCtrl = new VirtualBoardListCtrl(
			(wxWindow*) boardNoteBook, (const wxString) boardName,
			(const wxString) outputPath);

	//　boardName(key),boardTabAndTh(value)としてHashに格納する
	vbListCtrlHash[(const wxString) boardName] = (const VirtualBoardListCtrl&) vbListCtrl;
	// listctrl内のリストをJaneCloneのメモリに持たせる
	vbListHash[(const wxString) boardName] = vbListCtrl->m_vBoardList;

	// スレッドリストを表示させる
	boardNoteBook->AddPage(vbListCtrl, boardName, false);
	// カラムの幅を最大化
#ifdef __WXMSW__
	vbListCtrl->SetColumnWidth(1, wxLIST_AUTOSIZE);
	vbListCtrl->SetColumnWidth(8, wxLIST_AUTOSIZE);
	vbListCtrl->SetColumnWidth(9, wxLIST_AUTOSIZE);
	vbListCtrl->SetColumnWidth(10, wxLIST_AUTOSIZE);
#else
	// どうやらWindows以外ではリストの幅が適切に調整されないので
	// フォントの大きさから適切なリストの幅を算出する
	wxFont font = GetCurrentFont();
	int pointSize = font.GetPointSize();
	// 2chのスレタイの文字数制限は全角24文字
	vbListCtrl->SetColumnWidth(1, pointSize * 52);
	vbListCtrl->SetColumnWidth(8, pointSize * 12);
	vbListCtrl->SetColumnWidth(9, pointSize * 10);
	vbListCtrl->SetColumnWidth(10, pointSize * 12);
#endif

	// ノートブックの選択処理
	boardNoteBook->SetSelection(selectedPage);
	boardNoteBook->Thaw();

	m_mgr.Update();
}
/**
 * ノートブックに、スレッド一覧情報の更新を反映するメソッド
 */
void JaneClone::SetThreadListItemUpdate(const wxString boardName,
		const wxString outputPath, const size_t selectedPage) {

	// ノートブックの変更中はノートブックに触れないようにする
	boardNoteBook->Freeze();
	// HashMapから対象の板のオブジェクトを取り出す
	if (vbListCtrlHash.find(boardName) == vbListCtrlHash.end()) {
		wxMessageBox(wxT("スレッド一覧更新処理に失敗しました。"));
		boardNoteBook->Thaw();
	} else {
		// ハッシュ内部の情報を削除する
		vbListCtrlHash.erase(boardName);
		vbListHash.erase(boardName);

		VirtualBoardListCtrl* vbListCtrl = new VirtualBoardListCtrl(
				(wxWindow*) boardNoteBook, (const wxString) boardName,
				(const wxString) outputPath);

		//　boardName(key),boardTabAndTh(value)としてHashに格納する
		vbListCtrlHash[(const wxString) boardName] = (const VirtualBoardListCtrl&) vbListCtrl;
		// listctrl内のリストをJaneCloneのメモリに持たせる
		vbListHash[(const wxString) boardName] = vbListCtrl->m_vBoardList;

		boardNoteBook->DeletePage(selectedPage);
		boardNoteBook->InsertPage(selectedPage, vbListCtrl, boardName, false, wxNullBitmap);

		// カラムの幅を最大化
#ifdef __WXMSW__
		vbListCtrl->SetColumnWidth(1, wxLIST_AUTOSIZE);
		vbListCtrl->SetColumnWidth(8, wxLIST_AUTOSIZE);
		vbListCtrl->SetColumnWidth(9, wxLIST_AUTOSIZE);
		vbListCtrl->SetColumnWidth(10, wxLIST_AUTOSIZE);
#else
		// どうやらWindows以外ではリストの幅が適切に調整されないので
		// フォントの大きさから適切なリストの幅を算出する
		wxFont font = GetCurrentFont();
		int pointSize = font.GetPointSize();
		// 2chのスレタイの文字数制限は全角24文字
		vbListCtrl->SetColumnWidth(1, pointSize * 52);
		vbListCtrl->SetColumnWidth(8, pointSize * 12);
		vbListCtrl->SetColumnWidth(9, pointSize * 10);
		vbListCtrl->SetColumnWidth(10, pointSize * 12);
#endif
		// ノートブックの選択処理
		boardNoteBook->SetSelection(selectedPage);
		// ノートブックの解放
		boardNoteBook->Thaw();

		m_mgr.Update();
	}
}
/**
 * 板一覧更新処理
 */
void JaneClone::OnGetBoardList(wxCommandEvent&) {

	*m_logCtrl << wxT("三┏（ ；´ん｀）┛…板一覧更新\n");

	// ソケット通信を行う
	SocketCommunication* socketCommunication = new SocketCommunication();
	int rc = socketCommunication->DownloadBoardList(BOARD_LIST_PATH,
			BOARD_LIST_HEADER_PATH);
	delete socketCommunication;

	// 実行コード別のダイアログを出す
	if (rc != 0) {
		wxMessageBox(wxT("板一覧情報取得に失敗しました。ネットワークの接続状況を確認してください。"));
	} else {
		// もし板一覧情報テーブルが空でなければテーブルを削除しておく
		if (MetakitAccessor::TableHasView(wxT("BOARD_INFO"))) {
			MetakitAccessor::DropView(wxT("BOARD_INFO"));
		}
		// 板一覧情報を展開し、Metakitに設定する
		new ExtractBoardList(BOARD_LIST_PATH.mb_str());
		// 板一覧情報をセットする
		JaneClone::SetBoardList();

		*m_logCtrl << wxT("　　　(ヽ´ん`）　　 \n");
	}
}
/**
 * HtmlWindow上でマウスホバーが起きた場合の処理
 */
void JaneClone::OnCellHover(wxHtmlCellEvent& event) {

	wxHtmlCell* cell = event.GetCell();
	wxHtmlLinkInfo* linkInfo = cell->GetLink(cell->GetPosX(), cell->GetPosY());

	if (linkInfo) {
		if (linkInfo->GetHref() != wxEmptyString && linkInfo->GetTarget()
				== _T("_blank")) {
			// レスアンカーを察知した場合の処理
			// <a>タグ内サンプル　<a href="../test/read.cgi/poverty/1345636335/20" target="_blank">
			wxString href = linkInfo->GetHref();
			wxStringTokenizer tkz(href, wxT("//"));
			wxString boardNameAscii, orgNumber, resNumber;

			while (tkz.HasMoreTokens()) {
				wxString tmp = tkz.GetNextToken();
				if (tmp == _T("read.cgi")) {
					boardNameAscii = tkz.GetNextToken();
					orgNumber = tkz.GetNextToken();
					resNumber = tkz.GetNextToken();
					break;
				}
			}

			if (orgNumber == wxEmptyString || resNumber == wxEmptyString
					|| boardNameAscii == wxEmptyString) {
				return;
			}
			// アンカーの出現位置
			wxPoint anchorPoint(cell->GetPosX(), cell->GetPosY());
			// 取得した情報を元に新しいポップアップウィンドウを出現させる
			SetPopUpWindow(event, boardNameAscii, orgNumber, resNumber,
					anchorPoint);
		}
	}
}
/**
 * 特定のセルがクリックされた場合の処理
 */
void JaneClone::OnCellClicked(wxHtmlCellEvent& event) {
}
/*
 * 特定のリンクがクリックされた場合の処理
 */
void JaneClone::OnLinkClicked(wxHtmlLinkEvent& event) {
}
/**
 * スレッド一覧ノートブックで、タブが消される前の処理
 */
void JaneClone::OnAboutCloseThreadNoteBook(wxAuiNotebookEvent& event) {

	// 消されようとしているタブのタイトルを取得
	wxString title = threadNoteBook->GetPageText(threadNoteBook->GetSelection());
	// 固有番号を取得
	wxString origNumber = tiHash[title].origNumber;
	tcwHash.erase(origNumber);
	// ハッシュからタイトルのキーを持つデータを削除
	tiHash.erase(title);
}
/**
 * アクティブな板タブをひとつ閉じる
 */
void JaneClone::OneBoardTabClose(wxCommandEvent & event) {

	// アクティブなタブを選択して閉じる
	boardNoteBook->DeletePage(boardNoteBook->GetSelection());
}
/**
 * 現在選択されていないスレッド一覧タブを閉じる
 */
void JaneClone::ExcepSelTabClose(wxCommandEvent & event) {

	// タブの数を数える
	size_t pages = boardNoteBook->GetPageCount();
	size_t select = boardNoteBook->GetSelection();
	bool delete_f = false;

	for (unsigned int i=0;i<pages;i++) {

		if (i != select && !delete_f) {
			boardNoteBook->DeletePage(0);
		} else if (i == select && !delete_f) {
			boardNoteBook->DeletePage(1);
			delete_f = true;
		} else if (i != select && delete_f) {
			boardNoteBook->DeletePage(1);
		}
	}
}
/**
 * すべてのスレッド一覧タブを閉じる
 */
void JaneClone::AllBoardTabClose(wxCommandEvent& event) {

	int pages = boardNoteBook->GetPageCount();
	for (int i=0;i<pages;i++) {
		boardNoteBook->DeletePage(0);
	}
}
/**
 *　これより左のスレッド一覧タブをを閉じる
 */
void JaneClone::AllLeftBoardTabClose(wxCommandEvent& event) {

	// タブの数を数える
	size_t select = boardNoteBook->GetSelection();

	for (unsigned int i=0;i<select;i++) {
		boardNoteBook->DeletePage(0);
	}
}
/**
 *　これより右のスレッド一覧タブを閉じる
 */
void JaneClone::AllRightBoardTabClose(wxCommandEvent& event) {

	// タブの数を数える
	size_t pages = boardNoteBook->GetPageCount();
	size_t select = boardNoteBook->GetSelection();
	for (unsigned int i=0;i<pages;i++) {
		if (i>select) {
			boardNoteBook->DeletePage(select+1);
		}
	}
}
/**
 * スレッド一覧をブラウザで開く
 */
void JaneClone::OnOpenBoardByBrowser(wxCommandEvent& event) {

	wxString boardName = boardNoteBook->GetPageText(boardNoteBook->GetSelection());
	URLvsBoardName hash = retainHash[boardName];
	wxLaunchDefaultBrowser(hash.boardURL);
}
/**
 * アクティブなスレッド一覧をひとつ更新する
 */
void JaneClone::ReloadOneBoard(wxCommandEvent& event) {

	size_t page = boardNoteBook->GetSelection();
	wxString boardName = boardNoteBook->GetPageText(page);
	URLvsBoardName hash = retainHash[boardName];

	// スレ一覧をダウンロードする
	SocketCommunication* socketCommunication = new SocketCommunication();
	socketCommunication->SetLogWindow(m_logCtrl);
	wxString outputPath = socketCommunication->DownloadThreadList(boardName, hash.boardURL, hash.boardNameAscii);
	delete socketCommunication;

	// 更新をかける
	SetThreadListItemUpdate(boardName, outputPath, page);
}
/**
 * 板のURLをクリップボードにコピーする
 */
void JaneClone::CopyBURLToClipBoard(wxCommandEvent& event) {

	wxString boardName = boardNoteBook->GetPageText(
			boardNoteBook->GetSelection());
	URLvsBoardName hash = retainHash[boardName];

	if (wxTheClipboard->Open()) {
		wxTheClipboard->Clear();
		wxTheClipboard->SetData(new wxTextDataObject(hash.boardURL));
		wxTheClipboard->Close();
	}
}
/**
 * 板のタイトルをクリップボードにコピーする
 */
void JaneClone::CopyBTitleToClipBoard(wxCommandEvent& event) {

	wxString boardName = boardNoteBook->GetPageText(
			boardNoteBook->GetSelection());

	if (wxTheClipboard->Open()) {
		wxTheClipboard->Clear();
		wxTheClipboard->SetData(new wxTextDataObject(boardName));
		wxTheClipboard->Close();
	}
}
/**
 * 板のURLとタイトルをクリップボードにコピーする
 */
void JaneClone::CopyBBothDataToClipBoard(wxCommandEvent& event) {

	wxString boardName = boardNoteBook->GetPageText(
			boardNoteBook->GetSelection());
	URLvsBoardName hash = retainHash[boardName];

	if (wxTheClipboard->Open()) {
		wxTheClipboard->Clear();
		wxTheClipboard->SetData(new wxTextDataObject(boardName + wxT("\n") + hash.boardURL));
		wxTheClipboard->Close();
	}
}
/**
 * スレッドのURLをクリップボードにコピーする
 */
void JaneClone::CopyTURLToClipBoard(wxCommandEvent& event) {

	wxString title, boardNameAscii, origNumber, boardURL;

	title = threadNoteBook->GetPageText(
			threadNoteBook->GetSelection());
	boardNameAscii = tiHash[title].boardNameAscii;
	origNumber = tiHash[title].origNumber;

	// 仕方がないので総当りでハッシュからURLを探す
	NameURLHash::iterator it;
	for (it = retainHash.begin(); it != retainHash.end(); ++it) {
		wxString key = it->first;
		URLvsBoardName value = it->second;

		if (value.boardNameAscii == boardNameAscii) {
			boardURL = value.boardURL;
			break;
		}
	}

	wxString threadURL = boardURL;

	// ホスト名の後の板名を除く
	int begin = threadURL.Find(boardNameAscii);
	if (begin == wxNOT_FOUND) {
		return;
	}
	threadURL = threadURL.Mid(0, begin);
	threadURL += wxT("test/read.cgi/");
	threadURL += boardNameAscii;
	threadURL += wxT("/");
	threadURL += origNumber;
	threadURL += wxT("/");

	if (wxTheClipboard->Open()) {
		wxTheClipboard->Clear();
		wxTheClipboard->SetData(new wxTextDataObject(threadURL));
		wxTheClipboard->Close();
	}
}
/**
 * スレッドのタイトルをクリップボードにコピーする
 */
void JaneClone::CopyTTitleToClipBoard(wxCommandEvent& event) {

	wxString title = threadNoteBook->GetPageText(threadNoteBook->GetSelection());

	if (wxTheClipboard->Open()) {
		wxTheClipboard->Clear();
		wxTheClipboard->SetData(new wxTextDataObject(title));
		wxTheClipboard->Close();
	}
}
/**
 * スレッドのURLとタイトルをクリップボードにコピーする
 */
void JaneClone::CopyTBothDataToClipBoard(wxCommandEvent& event) {

	wxString title, boardNameAscii, origNumber, boardURL;

	title = threadNoteBook->GetPageText(
			threadNoteBook->GetSelection());
	boardNameAscii = tiHash[title].boardNameAscii;
	origNumber = tiHash[title].origNumber;

	// 仕方がないので総当りでハッシュからURLを探す
	NameURLHash::iterator it;
	for (it = retainHash.begin(); it != retainHash.end(); ++it) {
		wxString key = it->first;
		URLvsBoardName value = it->second;

		if (value.boardNameAscii == boardNameAscii) {
			boardURL = value.boardURL;
			break;
		}
	}

	wxString threadURL = boardURL;

	// ホスト名の後の板名を除く
	int begin = threadURL.Find(boardNameAscii);
	if (begin == wxNOT_FOUND) {
		return;
	}
	threadURL = threadURL.Mid(0, begin);
	threadURL += wxT("test/read.cgi/");
	threadURL += boardNameAscii;
	threadURL += wxT("/");
	threadURL += origNumber;
	threadURL += wxT("/");

	if (wxTheClipboard->Open()) {
		wxTheClipboard->SetData(new wxTextDataObject(title + wxT("\n") + threadURL));
		wxTheClipboard->Close();
	}
}
/**
 * 保存されているログをスレッド一覧に表示する
 */
void JaneClone::CheckLogDirectory(wxCommandEvent& event) {

	// ファイルパスの組み立て
	wxDir dir(wxGetCwd());
	wxString filePath = dir.GetName();

#ifdef __WXMSW__
	// Windowsではパスの区切りは"\"
	filePath += wxT("\\dat");
#else
	// それ以外ではパスの区切りは"/"
	filePath += wxT("/dat");
#endif

	// datファイルパスを開く
	wxDir datDir(filePath);
	if ( !datDir.IsOpened() )
		return;

	wxString dirName = datDir.GetName();
	wxArrayString allFileList;
	datDir.GetAllFiles(dirName, &allFileList, wxEmptyString, wxDIR_DIRS | wxDIR_FILES);
	allFileList.Shrink();

	// datファイルのみの配列に置き換える
	wxArrayString datList;

	for (unsigned int i=0;i < allFileList.GetCount();i++) {
		wxFileName* filename = new wxFileName(allFileList[i], wxPATH_NATIVE);
		if(filename->GetName().IsNumber() && allFileList[i].Contains(wxT(".dat"))) {
			// ファイル名が数字10桁で拡張子が「.dat」のものを取得する
			datList.Add(allFileList[i]);
		}
	}
	datList.Shrink();

	// ノートブックの変更中はノートブックに触れないようにする
	boardNoteBook->Freeze();

	// 新規にセットされる板名かどうかのフラグを用意する
	bool itIsNewBoardName = true;
	// 次に選択されるべきタブのページ数を格納する変数
	size_t selectedPage = 0;
	// 板名は「ログ一覧」で固定する
	wxString boardName = wxT("ログ一覧");

	// ユーザーが開いているタブの板名を調べる
	for (unsigned int i = 0; i < boardNoteBook->GetPageCount(); i++) {
		if (boardName.Cmp(boardNoteBook->GetPageText(i)) == 0) {
			itIsNewBoardName = false;
			selectedPage = i;
			break;
		}
	}

	// 仮想リストのインスタンス（スコープの外で宣言したい）
	VirtualBoardListCtrl* vbListCtrl;

	if (itIsNewBoardName) {
		/*
		 * 新規にログ一覧を作成する場合
		 */

		// ログ一覧用のインスタンスを準備する
		vbListCtrl = new VirtualBoardListCtrl(boardNoteBook, boardName, datList);

		//　boardName(key),boardTabAndTh(value)としてHashに格納する
		vbListCtrlHash[(const wxString) boardName] = (const VirtualBoardListCtrl&) vbListCtrl;
		// listctrl内のリストをJaneCloneのメモリに持たせる
		vbListHash[(const wxString) boardName] = vbListCtrl->m_vBoardList;
		// スレッドリストを表示させる
		boardNoteBook->AddPage(vbListCtrl, boardName, false);

	} else {
		/*
		 * 既にログ一覧がタブにある場合
		 */

		// ハッシュ内部の情報を削除する
		vbListCtrlHash.erase(boardName);
		vbListHash.erase(boardName);

		// ログ一覧用のインスタンスを準備する
		vbListCtrl = new VirtualBoardListCtrl(boardNoteBook, boardName, datList);

		//　boardName(key),boardTabAndTh(value)としてHashに格納する
		vbListCtrlHash[(const wxString) boardName] = (const VirtualBoardListCtrl&) vbListCtrl;
		// listctrl内のリストをJaneCloneのメモリに持たせる
		vbListHash[(const wxString) boardName] = vbListCtrl->m_vBoardList;

		boardNoteBook->DeletePage(selectedPage);
		boardNoteBook->InsertPage(selectedPage, vbListCtrl, boardName, false, wxNullBitmap);
	}

	// カラムの幅を最大化
#ifdef __WXMSW__
	vbListCtrl->SetColumnWidth(1, wxLIST_AUTOSIZE);
	vbListCtrl->SetColumnWidth(8, wxLIST_AUTOSIZE);
	vbListCtrl->SetColumnWidth(9, wxLIST_AUTOSIZE);
	vbListCtrl->SetColumnWidth(10, wxLIST_AUTOSIZE);
#else
	// どうやらWindows以外ではリストの幅が適切に調整されないので
	// フォントの大きさから適切なリストの幅を算出する
	wxFont font = GetCurrentFont();
	int pointSize = font.GetPointSize();
	// 2chのスレタイの文字数制限は全角24文字
	vbListCtrl->SetColumnWidth(1, pointSize * 52);
	vbListCtrl->SetColumnWidth(8, pointSize * 12);
	vbListCtrl->SetColumnWidth(9, pointSize * 10);
	vbListCtrl->SetColumnWidth(10, pointSize * 12);
#endif

	// ノートブックの選択処理
	boardNoteBook->SetSelection(selectedPage);
	boardNoteBook->Thaw();

	m_mgr.Update();
}
/**
 * スレタブをひとつ閉じる
 */
void JaneClone::OneThreadTabClose(wxCommandEvent& event) {

	// アクティブなタブを選択して閉じる
	threadNoteBook->DeletePage(threadNoteBook->GetSelection());
}
/**
 * 現在選択されていないスレタブを閉じる
 */
void JaneClone::ExcepSelThreadTabClose(wxCommandEvent& event) {

	// タブの数を数える
	size_t pages = threadNoteBook->GetPageCount();
	size_t select = threadNoteBook->GetSelection();
	bool delete_f = false;

	for (unsigned int i=0;i<pages;i++) {

		if (i != select && !delete_f) {
			threadNoteBook->DeletePage(0);
		} else if (i == select && !delete_f) {
			threadNoteBook->DeletePage(1);
			delete_f = true;
		} else if (i != select && delete_f) {
			threadNoteBook->DeletePage(1);
		}
	}
}
/**
 * すべてのスレタブを閉じる
 */
void JaneClone::AllThreadTabClose(wxCommandEvent& event) {

	int pages = threadNoteBook->GetPageCount();
	for (int i=0;i<pages;i++) {
		threadNoteBook->DeletePage(0);
	}
}
/**
 * これより左のスレタブをを閉じる
 */
void JaneClone::AllLeftThreadTabClose(wxCommandEvent& event) {

	// タブの数を数える
	size_t select = threadNoteBook->GetSelection();

	for (unsigned int i=0;i<select;i++) {
		threadNoteBook->DeletePage(0);
	}
}
/**
 * これより右のスレタブを閉じる
 */
void JaneClone::AllRightThreadTabClose(wxCommandEvent& event) {

	// タブの数を数える
	size_t pages = threadNoteBook->GetPageCount();
	size_t select = threadNoteBook->GetSelection();
	for (unsigned int i=0;i<pages;i++) {
		if (i>select) {
			threadNoteBook->DeletePage(select+1);
		}
	}
}
/**
 * スレッドをブラウザで開く
 */
void JaneClone::OnOpenThreadByBrowser(wxCommandEvent& event) {

	CopyTURLToClipBoard(event);

	if (wxTheClipboard->Open()) {
		wxTextDataObject data;
		wxTheClipboard->GetData(data);
		wxString url = data.GetText();
		wxTheClipboard->Close();
		wxLaunchDefaultBrowser(url);
	}
}
/**
 * datファイルに名前を付けて保存
 */
void JaneClone::SaveDatFile(wxCommandEvent& event) {

	wxString caption = wxT("datファイルに名前を付けて保存");
	wxString defaultDir = wxEmptyString; // OSのデフォルトに合わせる
	wxString wildCard = wxT("dat files (*.dat) |*.dat");

	// datファイル名の組み立て
	wxString title, boardNameAscii, origNumber, boardURL;

	title = threadNoteBook->GetPageText(threadNoteBook->GetSelection());
	boardNameAscii = tiHash[title].boardNameAscii;
	origNumber = tiHash[title].origNumber;

	// ファイルパスの組み立てとファイルの有無確認
	wxString filePath = JaneCloneUtil::AssembleFilePath(boardNameAscii, origNumber);

	if (!wxFile::Exists(filePath)) {
		// 無ければエラーメッセージ表示
		wxMessageBox(wxT("保存するためのdatファイルが見つかりませんでした"));
		return;
	}

	wxFileDialog dialog(this, caption, defaultDir, wxEmptyString, wildCard, wxFD_SAVE);
	dialog.SetPath(filePath);

	if (dialog.ShowModal() == wxID_OK) {
		bool ret = wxCopyFile(filePath, dialog.GetPath(), true);
		if (!ret) {
			wxMessageBox(wxT("datファイルの保存に失敗しました"));
		}
	}
}
/**
 * datをクリップボードにコピー
 */
void JaneClone::SaveDatFileToClipBoard(wxCommandEvent& event) {

	// datファイル名の組み立て
	wxString title, boardNameAscii, origNumber, boardURL;

	title = threadNoteBook->GetPageText(threadNoteBook->GetSelection());
	boardNameAscii = tiHash[title].boardNameAscii;
	origNumber = tiHash[title].origNumber;

	// ファイルパスの組み立てとファイルの有無確認
	wxString filePath = JaneCloneUtil::AssembleFilePath(boardNameAscii, origNumber);

	if (!wxFile::Exists(filePath)) {
		// 無ければエラーメッセージ表示
		wxMessageBox(wxT("保存するためのdatファイルが見つかりませんでした"));
		return;
	}

	if (wxTheClipboard->Open()) {
		wxFileDataObject* file = new wxFileDataObject();
		file->AddFile(filePath);

		wxTheClipboard->Clear();
		wxTheClipboard->SetData(file);
		wxTheClipboard->Close();
	}
}
/**
 * このログを削除
 */
void JaneClone::DeleteDatFile(wxCommandEvent& event) {

	// datファイル名の組み立て
	wxString title, boardNameAscii, origNumber, boardURL;

	title = threadNoteBook->GetPageText(threadNoteBook->GetSelection());
	boardNameAscii = tiHash[title].boardNameAscii;
	origNumber = tiHash[title].origNumber;

	// ファイルパスの組み立てとファイルの有無確認
	wxString filePath = JaneCloneUtil::AssembleFilePath(boardNameAscii, origNumber);

	if (!wxFile::Exists(filePath)) {
		// 無ければエラーメッセージ表示
		wxMessageBox(wxT("削除するためのdatファイルが見つかりませんでした"));
		return;
	}

	wxString message = wxString::Format("%s%s%s", wxT("ファイル"), filePath, wxT("を削除してよろしいですか？"));
	int result = wxMessageBox(message, wxEmptyString, wxOK | wxNO);

	if (result == wxOK) {
		wxRemoveFile(filePath);
	}
}
/**
 * スレッドの再読み込み
 */
void JaneClone::ReloadThisThread(wxCommandEvent& event) {

	// ノートブックの変更中はノートブックに触れないようにする
	threadNoteBook->Freeze();
	// 選択されたスレタブの情報を集める
	wxString boardName,boardURL, title, origNumber, boardNameAscii;
	size_t page = threadNoteBook->GetSelection();
	title = threadNoteBook->GetPageText(threadNoteBook->GetSelection());
	ThreadInfo info = tiHash[title];
	origNumber = info.origNumber;
	boardNameAscii = info.boardNameAscii;

	// 仕方がないので総当りでハッシュからURLを探す
	NameURLHash::iterator it;
	for (it = retainHash.begin(); it != retainHash.end(); ++it) {
		wxString key = it->first;
		URLvsBoardName value = it->second;

		if (value.boardNameAscii == boardNameAscii) {
			boardName = value.boardName;
			boardURL = value.boardURL;
			break;
		}
	}

	// アクティブなタブを選択して閉じる
	threadNoteBook->DeletePage(threadNoteBook->GetSelection());

	// ソケット通信を行う
	SocketCommunication* socketCommunication = new SocketCommunication();
	const wxString threadContentPath = socketCommunication->DownloadThread(boardName, boardURL, boardNameAscii, origNumber);
	delete socketCommunication;
	// 無事に通信が終了したならばステータスバーに表示
	this->SetStatusText(wxT(" スレッドのダウンロード終了"));

	// Hashに格納する板名タブのオブジェクトのインスタンスを準備する
	ThreadContentWindow* tcw = new ThreadContentWindow(
			(wxWindow*) threadNoteBook, threadContentPath);

	//　origNumber(key),ThreadContentWindow(value)としてHashに格納する
	tcwHash[origNumber] = tcw;

	// ノートブックに登録されたスレッド情報をハッシュに登録する
	info.origNumber = origNumber;
	info.boardNameAscii = boardNameAscii;
	tiHash[title] = info;

	*m_logCtrl << wxT("完了…　(´ん｀/)三\n");

	// スレッドを表示させる
	threadNoteBook->InsertPage(page, tcw, title, false, wxNullBitmap);
	threadNoteBook->SetSelection(page);
	threadNoteBook->Thaw();

	m_mgr.Update();
}
/**
 * Metakitから板一覧情報を抽出してレイアウトに反映するメソッド
 */
void JaneClone::SetBoardList() {
	// ArrayStringの形で板一覧情報を取得する
	wxArrayString boardInfoArray = MetakitAccessor::GetBoardInfo();
	// カテゴリ名一時格納用
	wxString categoryName;
	// 板名一時格納用
	wxString boardName;
	// URL一時格納用
	wxString url;

	// カテゴリ名を保持するためのID
	wxTreeItemId category;
	// Hashのカウント用Integer
	int hashID = 0;

	// 板一覧情報をツリーに渡す
	for (unsigned int i = 0; i < boardInfoArray.GetCount(); i += 3) {
		// カテゴリをツリーに登録
		if (categoryName != boardInfoArray[i + 2]) {
			category = m_tree_ctrl->AppendItem(m_rootId, boardInfoArray[i + 2],
					0, 0, m_treeData);
		}
		// それぞれの要素を一時格納
		boardName = boardInfoArray[i];
		url = boardInfoArray[i + 1];
		categoryName = boardInfoArray[i + 2];

		// ツリーに板名を追加する
		m_tree_ctrl->AppendItem(category, boardName, 1, 1, m_treeData);

		// 板名の配列に板名とURLを入れておく
		URLvsBoardName urlVsName;
		urlVsName.boardName = boardName;
		urlVsName.boardURL = url;

		// 正規表現を使ってサーバ名と板名(ascii)を取得する
		// そこまで難しい正規表現を使う必要はないようです
		wxRegEx reThreadList(_T("(http://)([^/]+)/([^/]+)"), wxRE_ADVANCED
				+ wxRE_ICASE);

		// 正規表現のコンパイルにエラーがなければ
		if (reThreadList.IsValid()) {
			// マッチさせる
			if (reThreadList.Matches(url)) {
				// マッチした文字列の３番目をいただく
				urlVsName.boardNameAscii = reThreadList.GetMatch(url, 3);
			}
		}
		// Hashに板情報を入れる
		if (!boardName.IsEmpty())
			retainHash[(const wxString) boardName]
					= (const URLvsBoardName&) urlVsName;
		// Hashのキー値をインクリメントしておく
		hashID++;
	}
}
/**
 * バージョン情報が書かれたダイアログを表示する
 */
void JaneClone::OnVersionInfo(wxCommandEvent&) {
	wxAboutDialogInfo info;
	info.SetName(wxT("Jane Clone - ２ちゃんねるビューア"));
	info.SetVersion(wxT("0.6.0"));
	info.SetDescription(wxT("Copyright(C) 2012 Nagata Hiroyuki, All Rights Reserved. "));
	info.SetCopyright(wxT("http://nantonaku-shiawase.hatenablog.com/"));

	wxAboutBox(info);
}
/**
 * 終了前処理では、保存しておきたいユーザー設定をMetakitに登録しておく
 */
void JaneClone::OnCloseWindow(wxCloseEvent& event) {

	// 終了処理中と表示する
	SetStatusText(wxT("終了前処理を実行中..."));

	/**
	 * 開いていた板の名前をmetakitに登録する
	 */
	wxArrayString userLookingBoardName;
	size_t bpages = boardNoteBook->GetPageCount();

	for (unsigned int i = 0; i < bpages; i++) {
		wxString pageText = boardNoteBook->GetPageText((size_t) i);
		// 空文字でなければ追加する
		if (!pageText.IsEmpty()) {
			userLookingBoardName.Add(pageText);
		}
	}

	// 開いていた板の一覧をmetakitに送る
	MetakitAccessor::SetUserLookingBoardList(userLookingBoardName);

	/**
	 * 開いていたスレッドの情報をmetakitに登録する
	 */
	wxArrayString userLookingThreadName;
	size_t tpages = threadNoteBook->GetPageCount();

	for (unsigned int i = 0; i < tpages; i++) {
		wxString pageText = threadNoteBook->GetPageText((size_t) i);
		// 空文字でなければ追加する
		if (!pageText.IsEmpty()) {
			userLookingThreadName.Add(pageText);
			userLookingThreadName.Add(tiHash[pageText].origNumber);
			userLookingThreadName.Add(tiHash[pageText].boardNameAscii);
		}
	}
	// 開いていたスレッドの一覧をmetakitに送る
	MetakitAccessor::SetUserLookingThreadList(userLookingThreadName);

	// wxAuiManagerのレイアウトの情報を保存する
	const wxString perspective = m_mgr.SavePerspective();
	config->Write(wxT("Perspective"), perspective);
	// フレームのレイアウト情報を保存する
	int x, y;
	this->GetSize(&x, &y);
	config->Write(wxT("FrameX"), x);
	config->Write(wxT("FrameY"), y);

	int px, py;
	this->GetPosition(&px, &py);
	config->Write(wxT("FramePx"), px);
	config->Write(wxT("FramePy"), py);

	// ウィンドウの最大化情報
	bool isMaximized = this->IsMaximized();
	config->Write(wxT("IsMaximized"), isMaximized);

	SetStatusText(wxT("終了前処理が終わりました！"));

	Destroy();
}
/**
 * 板一覧リストでのクリック時のイベント
 */
void JaneClone::OnLeftClickAtListCtrl(wxListEvent& event) {

	*m_logCtrl << wxT("スレッド取得　三　(　＾ν）\n");
	// 現在アクティブになっているタブの板名を取得する
	wxString boardName = boardNoteBook->GetPageText(
			boardNoteBook->GetSelection());

	if (vbListCtrlHash.find(boardName) == vbListCtrlHash.end()) {
		wxMessageBox(wxT("すでにダウンロードされているスレッド一覧ファイルの読み出しに失敗しました。datフォルダ内のデータを削除していませんか？"));
	} else {
		// リストコントロールを引き出してくる
		VirtualBoardListCtrl vbListCtrl =
				vbListCtrlHash[(const wxString) boardName];
		// ノートブックの移り変わり時にリストコントロールに入るべきリストをリフレッシュする
		VirtualBoardList vbList = vbListHash[(const wxString) boardName];
		vbListCtrl.m_vBoardList = vbList;

		// Hashから情報を引き出す
		URLvsBoardName hash = retainHash[boardName];
		wxString boardURL = hash.boardURL;
		wxString boardNameAscii = hash.boardNameAscii;

		// スレの固有番号とタイトルをリストから取り出す
		long index = event.GetIndex();
		const wxString origNumber(vbListCtrl.OnGetItemText(index, (long) 9));
		const wxString title(vbListCtrl.OnGetItemText(index, (long) 1));

		// ソケット通信を行う
		SocketCommunication* socketCommunication = new SocketCommunication();
		const wxString threadContentPath = socketCommunication->DownloadThread(
				boardName, boardURL, boardNameAscii, origNumber);
		delete socketCommunication;
		// 無事に通信が終了したならばステータスバーに表示
		this->SetStatusText(wxT(" スレッドのダウンロード終了"));

		// スレッドの内容をノートブックに反映する
		SetThreadContentToNoteBook(threadContentPath, origNumber, title);
		// ノートブックに登録されたスレッド情報をハッシュに登録する
		ThreadInfo info;
		info.origNumber = origNumber;
		info.boardNameAscii = boardNameAscii;
		tiHash[title] = info;

		*m_logCtrl << wxT("完了…　(´ん｀/)三\n");
	}
}
/**
 * スレッドをノートブックに反映するメソッド
 */
void JaneClone::SetThreadContentToNoteBook(const wxString& threadContentPath,
		const wxString& origNumber, const wxString& title) {

	// ノートブックの変更中はノートブックに触れないようにする
	threadNoteBook->Freeze();
	// Hashに格納する板名タブのオブジェクトのインスタンスを準備する
	ThreadContentWindow* tcw = new ThreadContentWindow(
			(wxWindow*) threadNoteBook, threadContentPath);

	//　origNumber(key),ThreadContentWindow(value)としてHashに格納する
	tcwHash[origNumber] = tcw;

	// スレッドを表示させる
	threadNoteBook->AddPage(tcw, title, false);
	threadNoteBook->Thaw();

	m_mgr.Update();
}
/**
 * 板一覧リスト・またはスレッド一覧タブを変更した時のイベント
 */
void JaneClone::OnChangedTab(wxAuiNotebookEvent& event) {

	if (wxNOT_FOUND != event.GetOldSelection()) {
		// イベント以前に選択していたタブがある場合選択したタブの板名を取得する
		wxString selectedBoardName = boardNoteBook->GetPageText(
				event.GetSelection());
		VirtualBoardListCtrl vbListCtrl =
				vbListCtrlHash[(const wxString) selectedBoardName];

		// ノートブックの変更中はノートブックに触れないようにする
		boardNoteBook->Freeze();
		if (vbListCtrl.GetItemCount() != 0) {
			// リストコントロールのアイテムの数が0でなければ
			vbListCtrl.RefreshItems(0, vbListCtrl.GetItemCount());
		}

		// ノートブックの解放
		boardNoteBook->Thaw();
		m_mgr.Update();
	}
}
/**
 * 板一覧ノートブックで右クリックされた時の処理
 */
void JaneClone::OnRightClickBoardNoteBook(wxAuiNotebookEvent& event) {
	wxString selectedBoardName = boardNoteBook->GetPageText(
			event.GetSelection());

	wxMenu* boardTabUtil = new wxMenu();
	boardTabUtil->Append(ID_OneBoardTabClose, wxT("このタブを閉じる"));
	boardTabUtil->AppendSeparator();
	boardTabUtil->Append(ID_ExcepSelTabClose, wxT("このタブ以外を閉じる"));
	boardTabUtil->Append(ID_AllBoardTabClose, wxT("すべてのタブを閉じる"));
	boardTabUtil->Append(ID_AllLeftBoardTabClose, wxT("これより左を閉じる"));
	boardTabUtil->Append(ID_AllRightBoardTabClose, wxT("これより右を閉じる"));
	boardTabUtil->AppendSeparator();
	boardTabUtil->Append(ID_ReloadOneBoard, wxT("スレ一覧更新"));
	boardTabUtil->Append(wxID_ANY, wxT("新着をすべて開く"));
	boardTabUtil->Append(wxID_ANY, wxT("お気に入りの新着をすべて開く"));
	boardTabUtil->Append(wxID_ANY, wxT("新着スレッドをすべて開く"));
	boardTabUtil->AppendSeparator();

	wxMenu* addFav = new wxMenu();
	addFav->Append(wxID_ANY, wxT("「お気に入り」に追加"));
	addFav->AppendSeparator();
	addFav->Append(wxID_ANY, wxT("「リンク」に追加"));
	boardTabUtil->AppendSubMenu(addFav, wxT("お気に入りに追加"));
	boardTabUtil->AppendSeparator();

	boardTabUtil->Append(wxID_ANY, wxT("スレッド新規作成"));
	boardTabUtil->AppendSeparator();
	boardTabUtil->Append(ID_OnOpenBoardByBrowser, wxT("ブラウザで開く"));
	boardTabUtil->Append(wxID_ANY, wxT("index表示"));
	boardTabUtil->Append(wxID_ANY, wxT("看板を見る"));
	boardTabUtil->AppendSeparator();

	boardTabUtil->AppendSeparator();
	wxMenu* copy = new wxMenu();
	copy->Append(ID_CopyBURLToClipBoard, wxT("URLをコピー"));
	copy->Append(ID_CopyBTitleToClipBoard, wxT("タイトルをコピー"));
	copy->Append(ID_CopyBBothDataToClipBoard, wxT("タイトルとURLをコピー"));
	boardTabUtil->AppendSubMenu(copy, wxT("コピー"));
	boardTabUtil->AppendSeparator();

	wxMenu* deleteLog = new wxMenu();
	deleteLog->Append(wxID_ANY, wxT("すべてのログを削除"));
	deleteLog->Append(wxID_ANY, wxT("お気に入り以外のログを削除"));
	boardTabUtil->AppendSubMenu(deleteLog, wxT("ログ削除"));
	boardTabUtil->AppendSeparator();

	boardTabUtil->Append(wxID_ANY, wxT("板移転の追尾"));
	boardTabUtil->AppendSeparator();
	boardTabUtil->Append(wxID_ANY, wxT("板のインデックスを再構築"));
	boardTabUtil->Append(wxID_ANY, wxT("過去ログ非表示"));

	// ポップアップメニューを表示させる
	PopupMenu(boardTabUtil);
}
/**
 * スレッド一覧ノートブックで右クリックされた時の処理
 */
void JaneClone::OnRightClickThreadNoteBook(wxAuiNotebookEvent& event) {
	wxString selectedThreadName = threadNoteBook->GetPageText(
			event.GetSelection());

	wxMenu* threadTabUtil = new wxMenu();
	threadTabUtil->Append(ID_OneThreadTabClose, wxT("このタブを閉じる"));
	threadTabUtil->Append(wxID_ANY, wxT("未読として閉じる"));
	threadTabUtil->AppendSeparator();
	threadTabUtil->Append(ID_ExcepSelThreadTabClose, wxT("このタブ以外を閉じる"));
	threadTabUtil->Append(wxID_ANY, wxT("新着なしのタブを閉じる"));
	threadTabUtil->Append(ID_AllThreadTabClose, wxT("すべてのタブを閉じる"));
	threadTabUtil->Append(ID_AllLeftThreadTabClose, wxT("これより左を閉じる"));
	threadTabUtil->Append(ID_AllRightThreadTabClose, wxT("これより右を閉じる"));
	threadTabUtil->AppendSeparator();

	wxMenu *tabLock = new wxMenu;
	tabLock->Append(wxID_ANY, wxT("このタブをロックする"));
	tabLock->Append(wxID_ANY, wxT("すべてのタブをロックする"));
	tabLock->Append(wxID_ANY, wxT("これより左をロックする"));
	tabLock->Append(wxID_ANY, wxT("これより右をロックする"));
	threadTabUtil->AppendSubMenu(tabLock, wxT("タブロック"));
	threadTabUtil->AppendSeparator();

	threadTabUtil->Append(wxID_ANY, wxT("次スレ候補検索"));
	threadTabUtil->Append(wxID_ANY, wxT("次スレ候補を開く"));
	threadTabUtil->Append(wxID_ANY, wxT("ヒストリー検索"));
	threadTabUtil->AppendSeparator();

	threadTabUtil->Append(wxID_ANY, wxT("印を付ける"));

	wxMenu* addFav = new wxMenu();
	addFav->Append(wxID_ANY, wxT("「お気に入り」に追加"));
	addFav->AppendSeparator();
	addFav->Append(wxID_ANY, wxT("「リンク」に追加"));
	threadTabUtil->AppendSubMenu(addFav, wxT("お気に入りに追加"));
	threadTabUtil->AppendSeparator();

	wxMenu* addFavAll = new wxMenu();
	addFavAll->Append(wxID_ANY, wxT("「お気に入り」に追加"));
	addFavAll->AppendSeparator();
	addFavAll->Append(wxID_ANY, wxT("「リンク」に追加"));
	threadTabUtil->AppendSubMenu(addFavAll, wxT("すべてのタブをお気に入りに追加"));
	threadTabUtil->AppendSeparator();

	threadTabUtil->Append(wxID_ANY, wxT("新着チェック"));
	threadTabUtil->Append(wxID_ANY, wxT("すべてのタブの新着チェック"));
	threadTabUtil->Append(wxID_ANY, wxT("中止"));
	threadTabUtil->Append(wxID_ANY, wxT("レス"));
	threadTabUtil->AppendSeparator();
	threadTabUtil->Append(ID_OnOpenThreadByBrowser, wxT("ブラウザで開く"));
	threadTabUtil->AppendSeparator();

	wxMenu* copy = new wxMenu();
	copy->Append(ID_CopyTURLToClipBoard, wxT("URLをコピー"));
	copy->Append(ID_CopyTTitleToClipBoard, wxT("タイトルをコピー"));
	copy->Append(ID_CopyTBothDataToClipBoard, wxT("タイトルとURLをコピー"));
	threadTabUtil->AppendSubMenu(copy, wxT("コピー"));
	threadTabUtil->AppendSeparator();

	threadTabUtil->Append(wxID_ANY, wxT("この板を開く"));
	threadTabUtil->AppendSeparator();

	wxMenu *broadcast = new wxMenu;
	broadcast->Append(wxID_ANY, wxT("オートリロード"));
	broadcast->Append(wxID_ANY, wxT("オートスクロール"));
	broadcast->Append(wxID_ANY, wxT("オートリロード・スクロール"));
	threadTabUtil->AppendSubMenu(broadcast, wxT("実況支援"));
	threadTabUtil->AppendSeparator();

	wxMenu *iReadHere = new wxMenu;
	iReadHere->Append(wxID_ANY, wxT("この辺まで読んだ"));
	iReadHere->Append(wxID_ANY, wxT("最後まで読んだ"));
	iReadHere->Append(wxID_ANY, wxT("「ここまで読んだ」にジャンプ"));
	iReadHere->Append(wxID_ANY, wxT("「ここまで読んだ」を解除"));
	threadTabUtil->AppendSubMenu(iReadHere, wxT("ここまで読んだ"));

	wxMenu *chkResponse = new wxMenu;
	chkResponse->Append(wxID_ANY, wxT("レスのチェックをすべて解除"));
	threadTabUtil->AppendSubMenu(chkResponse, wxT("レスのチェック"));
	threadTabUtil->AppendSeparator();

	wxMenu *saveLog = new wxMenu;
	saveLog->Append(ID_SaveDatFile, wxT("datを名前を付けて保存"));
	saveLog->Append(ID_SaveDatFileToClipBoard, wxT("datをクリップボードにコピー"));
	threadTabUtil->AppendSubMenu(saveLog, wxT("このログを保存"));
	threadTabUtil->Append(ID_DeleteDatFile, wxT("このログを削除"));
	threadTabUtil->Append(ID_ReloadThisThread, wxT("再読み込み"));

	// Linuxではファイルごとクリップボードにコピーすることができない
#ifndef __WXMSW__
	saveLog->Enable(ID_SaveDatFileToClipBoard, false);
#endif

	// ポップアップメニューを表示させる
	PopupMenu(threadTabUtil);
}
/**
 * レスアンカーに対応するレスを表示するポップアップウィンドウを出現させる
 */
void JaneClone::SetPopUpWindow(wxHtmlCellEvent& event,
		wxString& boardNameAscii, wxString& origNumber, wxString& resNumber,
		wxPoint& anchorPoint) {

	// アンカーが指し示すHTMLソースを取得する
	wxString htmlDOM = JaneCloneUtil::FindAnchoredResponse(boardNameAscii,
			origNumber, resNumber);

	if (wxEmptyString == htmlDOM) {
		// 空文字で帰ってきたらリターン
		return;
	}

	// 取得したレスをポップアップさせる
	AnchoredResponsePopup* popup = new AnchoredResponsePopup(threadNoteBook,
			anchorPoint, wxSize(640, 300), htmlDOM);

	// マウスカーソルの位置に調整する
	wxPoint p = ClientToScreen(wxGetMousePosition());
	popup->Position(anchorPoint, wxSize(p.x + 50, p.y - 50));
	popup->Popup();
}
/**
 * 現在使用しているフォントの情報を取得する
 */
wxFont JaneClone::GetCurrentFont() {
	// wxFontのサンプルコードを参照
	wxFont font(wxNORMAL_FONT->GetPointSize(), wxFONTFAMILY_DEFAULT,
			wxFONTSTYLE_NORMAL, wxFONTWEIGHT_NORMAL, false /* !underlined */,
			wxEmptyString /* facename */, wxFONTENCODING_UTF8);

	if (font.IsOk()) {
		return font;
	}
	// フォントが取得できなかった場合
	return *wxFont::New(10, wxFONTFAMILY_DEFAULT, wxFONTSTYLE_NORMAL,
			wxFONTWEIGHT_NORMAL, false, wxEmptyString, wxFONTENCODING_UTF8);
}

