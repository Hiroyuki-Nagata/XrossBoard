/* JaneClone - a text board site viewer for 2ch
 * Copyright (C) 2012 Hiroyuki Nagata
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * Contributor:
 *	Hiroyuki Nagata <newserver002@gmail.com>
 */

// -*- C++ -*- generated by wxGlade 0.6.3 on Tue Nov 01 01:42:24 2011
#include "janeclone.hpp"

#ifndef __WXMSW__
#include"../rc/janeclone.xpm"
#endif

// マクロ置換用マクロ
#define XSTR(x) #x
#define STR(x)  XSTR(x)

// event table
BEGIN_EVENT_TABLE(JaneClone, wxFrame)
// メニューバー・ポップアップメニューにあるコマンド入力で起動するメソッドのイベントテーブル
EVT_MENU(ID_Quit, JaneClone::OnQuit)
EVT_MENU(ID_Restart, JaneClone::OnRestart)
EVT_MENU(ID_GetBoardList, JaneClone::OnGetBoardList)
EVT_MENU(ID_CheckLogDirectory, JaneClone::CheckLogDirectory)
EVT_MENU(ID_GetVersionInfo, JaneClone::OnVersionInfo)
EVT_MENU(ID_OneBoardTabClose, JaneClone::OneBoardTabClose)
EVT_MENU(ID_ExcepSelTabClose, JaneClone::ExcepSelTabClose)
EVT_MENU(ID_AllBoardTabClose, JaneClone::AllBoardTabClose)
EVT_MENU(ID_AllLeftBoardTabClose, JaneClone::AllLeftBoardTabClose)
EVT_MENU(ID_AllRightBoardTabClose, JaneClone::AllRightBoardTabClose)
EVT_MENU(ID_OnOpenBoardByBrowser, JaneClone::OnOpenBoardByBrowser)
EVT_MENU(ID_ReloadOneBoard, JaneClone::ReloadOneBoard)
EVT_MENU(ID_CopyBURLToClipBoard, JaneClone::CopyBURLToClipBoard)
EVT_MENU(ID_CopyBTitleToClipBoard, JaneClone::CopyBTitleToClipBoard)
EVT_MENU(ID_CopyBBothDataToClipBoard, JaneClone::CopyBBothDataToClipBoard)
EVT_MENU(ID_CopyTURLToClipBoard, JaneClone::CopyTURLToClipBoard)
EVT_MENU(ID_CopyTTitleToClipBoard, JaneClone::CopyTTitleToClipBoard)
EVT_MENU(ID_CopyTBothDataToClipBoard, JaneClone::CopyTBothDataToClipBoard)
EVT_MENU(ID_OneThreadTabClose, JaneClone::OneThreadTabClose)
EVT_MENU(ID_ExcepSelThreadTabClose, JaneClone::ExcepSelThreadTabClose)
EVT_MENU(ID_AllThreadTabClose, JaneClone::AllThreadTabClose)
EVT_MENU(ID_AllLeftThreadTabClose, JaneClone::AllLeftThreadTabClose)
EVT_MENU(ID_AllRightThreadTabClose, JaneClone::AllRightThreadTabClose)
EVT_MENU(ID_OnOpenThreadByBrowser, JaneClone::OnOpenThreadByBrowser)
EVT_MENU(ID_SaveDatFile, JaneClone::SaveDatFile)
EVT_MENU(ID_SaveDatFileToClipBoard, JaneClone::SaveDatFileToClipBoard)
EVT_MENU(ID_DeleteDatFile, JaneClone::DeleteDatFile)
EVT_MENU(ID_ReloadThisThread, JaneClone::ReloadThisThread)
EVT_MENU(ID_CallResponseWindow, JaneClone::CallResponseWindow)
EVT_MENU(ID_FontDialogBoardTree, JaneClone::FontDialogBoardTree)
EVT_MENU(ID_FontDialogLogWindow, JaneClone::FontDialogLogWindow)
EVT_MENU(ID_FontDialogBoardNotebook, JaneClone::FontDialogBoardNotebook)
EVT_MENU(ID_FontDialogThreadNotebook, JaneClone::FontDialogThreadNotebook)
EVT_MENU(ID_FontDialogThreadContents, JaneClone::FontDialogThreadContents)
EVT_MENU(ID_OnOpenJaneCloneOfficial, JaneClone::OnOpenJaneCloneOfficial)

// メニューバーからスレッド一覧リストをソート
EVT_MENU(ID_OnClickMenuCOL_CHK,      JaneClone::OnThreadListSort)
EVT_MENU(ID_OnClickMenuCOL_NUM,      JaneClone::OnThreadListSort)
EVT_MENU(ID_OnClickMenuCOL_TITLE,    JaneClone::OnThreadListSort)
EVT_MENU(ID_OnClickMenuCOL_RESP,     JaneClone::OnThreadListSort)
EVT_MENU(ID_OnClickMenuCOL_CACHEDRES,JaneClone::OnThreadListSort)
EVT_MENU(ID_OnClickMenuCOL_NEWRESP,  JaneClone::OnThreadListSort)
EVT_MENU(ID_OnClickMenuCOL_INCRESP,  JaneClone::OnThreadListSort)
EVT_MENU(ID_OnClickMenuCOL_MOMENTUM, JaneClone::OnThreadListSort)
EVT_MENU(ID_OnClickMenuCOL_LASTUP,   JaneClone::OnThreadListSort)
EVT_MENU(ID_OnClickMenuCOL_SINCE,    JaneClone::OnThreadListSort)
EVT_MENU(ID_OnClickMenuCOL_OID,      JaneClone::OnThreadListSort)
EVT_MENU(ID_OnClickMenuCOL_BOARDNAME,JaneClone::OnThreadListSort)

// 検索バー系の命令
EVT_MENU(ID_SearchBoxDoSearch, JaneClone::SearchBoxDoSearch)
EVT_MENU(ID_SearchBarHide, JaneClone::HideSearchBar)
EVT_MENU(ID_SearchBoxUp, JaneClone::SearchBoxUp)
EVT_MENU(ID_SearchBoxDown, JaneClone::SearchBoxDown)
EVT_MENU(ID_SearchBoxCopy, JaneClone::SearchBoxCopy)
EVT_MENU(ID_SearchBoxCut, JaneClone::SearchBoxCut)
EVT_MENU(ID_SearchBoxSelectAll, JaneClone::SearchBoxSelectAll)
EVT_MENU(ID_SearchBoxClear, JaneClone::SearchBoxClear)

// 動的に項目を追加するメニューでのイベント
EVT_MENU_OPEN(JaneClone::OnMenuOpen)
EVT_UPDATE_UI(ID_UserLastClosedThreadMenuUp, JaneClone::UserLastClosedThreadMenuUp)
EVT_UPDATE_UI(ID_UserLastClosedBoardMenuUp, JaneClone::UserLastClosedBoardMenuUp)
EVT_UPDATE_UI(ID_UserLookingTabsMenuUp, JaneClone::UserLookingTabsMenuUp)

// ツリーコントロールのイベント
EVT_TREE_SEL_CHANGED(wxID_ANY, JaneClone::OnGetBoardInfo)

// 板一覧ノートブックで右クリックされた時の処理
EVT_AUINOTEBOOK_TAB_RIGHT_DOWN(ID_BoardNoteBook, JaneClone::OnRightClickBoardNoteBook)
// スレッド一覧ノートブックで右クリックされた時の処理
EVT_AUINOTEBOOK_TAB_RIGHT_DOWN(ID_ThreadNoteBook, JaneClone::OnRightClickThreadNoteBook)

// 板一覧ノートブックで、タブが消される前の処理
EVT_AUINOTEBOOK_PAGE_CLOSE(ID_BoardNoteBook, JaneClone::OnAboutCloseBoardNoteBook)
// スレッド一覧ノートブックで、タブが消される前の処理
EVT_AUINOTEBOOK_PAGE_CLOSE(ID_ThreadNoteBook, JaneClone::OnAboutCloseThreadNoteBook)

// AuiNotebookのタブを変更中の処理
EVT_AUINOTEBOOK_PAGE_CHANGING(ID_BoardNoteBook, JaneClone::OnChangeBoardTab)
EVT_AUINOTEBOOK_PAGE_CHANGING(ID_ThreadNoteBook, JaneClone::OnChangeThreadTab)
// AuiNotebookのタブを変更し終わった時の処理
EVT_AUINOTEBOOK_PAGE_CHANGED(ID_BoardNoteBook, JaneClone::OnChangedBoardTab)
EVT_AUINOTEBOOK_PAGE_CHANGED(ID_ThreadNoteBook, JaneClone::OnChangedThreadTab)

// フォーカスの監視
EVT_SET_FOCUS(JaneClone::OnSetFocus)

// マウスモーションの監視
EVT_ENTER_WINDOW(JaneClone::MotionEnterWindow)
EVT_LEAVE_WINDOW(JaneClone::MotionLeaveWindow)

// スレッド一覧リストでのクリック
EVT_LIST_ITEM_SELECTED(wxID_ANY, JaneClone::OnLeftClickAtListCtrl)
EVT_LIST_COL_CLICK(wxID_ANY, JaneClone::OnLeftClickAtListCtrlCol)
// 終了前処理
EVT_CLOSE(JaneClone::OnCloseWindow)
// wxHtmlWindow上でのイベント処理
EVT_HTML_CELL_HOVER(wxID_ANY, JaneClone::OnCellHover)
// URL入力ウィンドウのボタンイベント処理
EVT_BUTTON(ID_URLWindowButton, JaneClone::OnClickURLWindowButton)

END_EVENT_TABLE()

// 画像ビューアのインスタンスを初期化
JaneCloneImageViewer* JaneClone::imageViewer = NULL;

// インスタンスを渡す処理
JaneCloneImageViewer* JaneClone::GetJaneCloneImageViewer () {

     if (imageViewer != NULL) {
	  return imageViewer;
     }
     // !! ここ以下のコードは多分動かない !!
     // 画像ビューアのインスタンスを作る
     imageViewer = new JaneCloneImageViewer(NULL, wxID_ANY, wxT("画像ビューア"));
     // 通常は隠しておく
     imageViewer->Show(false);     
     return imageViewer;
}


JaneClone::JaneClone(wxWindow* parent, int id, const wxString& title, const wxPoint& pos, const wxSize& size, long style):
     wxFrame(parent, id, title, pos, size, wxDEFAULT_FRAME_STYLE)
{
     // アイコンの設定
#ifdef __WXMSW__
     SetIcon(wxICON(wxicon));
#else
     SetIcon(wxICON(janeclone));
#endif

     /**
      * 必要なwxWindowを宣言する
      */
     // 検索バー
     m_search_ctrl = new wxSearchCtrl((wxWindow*)this, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxTE_PROCESS_ENTER);
     // URL入力欄
     m_url_input_panel = new wxPanel(this, wxID_ANY);
     m_url_input = new wxTextCtrl(m_url_input_panel, wxID_ANY, m_url_text, wxDefaultPosition, wxDefaultSize);
     m_url_input_button = new wxBitmapButton(m_url_input_panel, ID_URLWindowButton, wxBitmap(wxT("rc/go-next.png"), wxBITMAP_TYPE_ANY));
     // ログ出力ウィンドウ
     m_logCtrl = new wxTextCtrl(this, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxTE_MULTILINE | wxTE_READONLY);
     wxFont font;
     font.SetNativeFontInfoUserDesc(wxT("MS PGothic 12 CP932"));
     wxTextAttr attr;
     attr.SetFont(font);
     m_logCtrl->SetDefaultStyle(attr);

     // 板一覧ツリー
     m_boardTreePanel = new wxPanel(this);

     *m_logCtrl << wxT("(ヽ´ん`)…デバッグ用画面…\n");
     // ステータスバー設置
     this->CreateStatusBar(2);

     // わかりやすい画像つき各種処理ボタン

     // 各種GUI設定を行う
     SetJaneCloneManuBar();
     SetProperties();
     DoLayout();

     // ユーザーが前回までに見ていた板一覧タブとスレッド一覧タブをセットする
     SetPreviousUserLookedTab();
     boardNoteBook->Update();
     threadNoteBook->Update();

     SetStatusText(wxT(" 完了"));
     *m_logCtrl << wxT("(ヽ´ん`)…レイアウト設定終わりです…\n");
}
/**
 * SetJaneCloneManuBar
 * メニューバーの設定を行う
 */
void JaneClone::SetJaneCloneManuBar() {
     /*
      * メニューバーの設置
      */
     wxMenuBar *menuBar = new wxMenuBar;
     /**
      * ファイル部分
      */
     wxMenu *menu1 = new wxMenu;
     menu1->AppendSeparator();
     this->closeT = new wxMenu;
     // 動的に項目を補充する
     closeT->Append(ID_UserLastClosedThreadMenuUp, wxT("最後に閉じたスレを開く"), wxT("最後に閉じたスレを開きます"));
     closeT->AppendSeparator();

     menu1->AppendSubMenu(closeT, wxT("最近閉じたスレ"), wxT("最近閉じたスレを開きます"));
     this->closeB = new wxMenu;
     // 動的に項目を補充する
     closeB->Append(ID_UserLastClosedBoardMenuUp, wxT("最後に閉じた板を開く"), wxT("最後に閉じた板を開きます"));
     closeB->AppendSeparator();

     menu1->AppendSubMenu(closeB, wxT("最近閉じた板"));
     menu1->AppendSeparator();
     menu1->Append(ID_Restart, wxT("再起動"), wxT("JaneCloneを再起動します"));
     menu1->Append(ID_Quit, wxT("終了"), wxT("JaneCloneを終了します"));
     /**
      * 表示部分
      */
     wxMenu *menu2 = new wxMenu;
     wxMenu* font = new wxMenu();
     font->Append(ID_FontDialogBoardTree, wxT("板一覧ツリー"), wxT("板一覧ツリーで使用するフォントを設定します"));
     font->Append(ID_FontDialogLogWindow, wxT("ログ出力画面"), wxT("ログ出力画面で使用するフォントを設定します"));
     font->Append(ID_FontDialogBoardNotebook, wxT("スレッド一覧画面"), wxT("スレッド一覧画面で使用するフォントを設定します"));
     font->Append(ID_FontDialogThreadNotebook, wxT("開いているスレ"), wxT("開いているスレ画面で使用するフォントを設定します"));
     font->Append(ID_FontDialogThreadContents, wxT("スレッド内"), wxT("スレッド内で使用するフォントを設定します"));
     menu2->AppendSubMenu(font, wxT("フォント設定"));
     /**
      * 板覧部分
      */
     wxMenu *menu3 = new wxMenu;
     menu3->Append(ID_GetBoardList, wxT("板一覧の更新"));
     menu3->AppendSeparator();
     menu3->Append(wxID_ANY, wxT("お気に入りを板として開く"));
     menu3->Append(wxID_ANY, wxT("ログ一覧を開く"));
     menu3->Append(wxID_ANY, wxT("開いているスレッドを板として開く"));
     menu3->Append(wxID_ANY, wxT("最近読み込んだスレッド"));
     menu3->Append(wxID_ANY, wxT("最近書き込んだスレッド"));
     menu3->AppendSeparator();
     menu3->Append(ID_CheckLogDirectory, wxT("ログフォルダのチェック"));
     menu3->AppendSeparator();
     menu3->Append(wxID_ANY, wxT("すべての板のインデックスを再構築"));
     menu3->Append(wxID_ANY, wxT("ログの再構築"));
     menu3->AppendSeparator();
     menu3->Append(wxID_ANY, wxT("ログ一覧制限変更"));
     menu3->Append(wxID_ANY, wxT("ログ一覧から取り込む"));
     menu3->AppendSeparator();
     menu3->Append(wxID_ANY, wxT("新規板登録"));
     /**
      * スレ覧部分
      */
     wxMenu *menu4 = new wxMenu;
     wxMenu *closeB = new wxMenu;
     closeB->Append(ID_OneBoardTabClose, wxT("現在の板を閉じる"));
     closeB->AppendSeparator();
     closeB->Append(ID_ExcepSelTabClose, wxT("選択されていない板を閉じる"));
     closeB->Append(ID_AllBoardTabClose, wxT("すべてのタブを閉じる"));
     closeB->Append(ID_AllLeftBoardTabClose, wxT("これより左を閉じる"));
     closeB->Append(ID_AllRightBoardTabClose, wxT("これより右を閉じる"));
     menu4->AppendSubMenu(closeB, wxT("閉じる"));
     menu4->AppendSeparator();
     wxMenu *open = new wxMenu;
     open->Append(wxID_ANY, wxT("新着をすべて開く"));
     open->Append(wxID_ANY, wxT("お気に入りの新着をすべて開く"));
     open->Append(wxID_ANY, wxT("新着スレッドをすべて開く"));
     open->AppendSeparator();
     open->Append(wxID_ANY, wxT("新着のあるスレッドを一件開く"));
     open->AppendSeparator();
     open->Append(wxID_ANY, wxT("新しいタブで開く"));
     open->Append(wxID_ANY, wxT("今のタブで開く"));
     open->Append(wxID_ANY, wxT("バックグラウンドで開く"));
     menu4->AppendSubMenu(open, wxT("開く"));
     menu4->AppendSeparator();
     menu4->Append(wxID_ANY, wxT("選択中のスレを閉じる"));
     menu4->AppendSeparator();
     menu4->Append(wxID_ANY, wxT("選択中のスレをタブロック"));
     menu4->Append(wxID_ANY, wxT("既読にする"));
     menu4->Append(wxID_ANY, wxT("印を付ける"));
     menu4->Append(wxID_ANY, wxT("お気に入りに追加"));
     menu4->Append(wxID_ANY, wxT("お気に入りを削除"));
     menu4->AppendSeparator();
     menu4->Append(ID_ReloadOneBoard, wxT("スレ一覧更新"));
     menu4->Append(wxID_ANY, wxT("すべてのタブのスレ一覧更新"));
     menu4->Append(wxID_ANY, wxT("板移転の追尾"));
     menu4->AppendSeparator();
     menu4->Append(wxID_ANY, wxT("スレッド新規作成"));
     menu4->AppendSeparator();
     menu4->Append(ID_OnOpenBoardByBrowser, wxT("ブラウザで開く"));
     menu4->Append(wxID_ANY, wxT("看板を見る"));
     menu4->AppendSeparator();
     wxMenu *selectCopy = new wxMenu;
     selectCopy->Append(wxID_ANY, wxT("datをクリップボードにコピー"));
     menu4->AppendSubMenu(selectCopy, wxT("選択中のログをコピー"));
     wxMenu *copy = new wxMenu;
     copy->Append(ID_CopyBURLToClipBoard, wxT("URLをコピー"));
     copy->Append(ID_CopyBTitleToClipBoard, wxT("タイトルをコピー"));
     copy->Append(ID_CopyBBothDataToClipBoard, wxT("タイトルとURLをコピー"));
     menu4->AppendSubMenu(copy, wxT("コピー"));
     menu4->AppendSeparator();
     wxMenu *deleteLog = new wxMenu;
     deleteLog->Append(wxID_ANY, wxT("選択中のログを削除"));
     deleteLog->Append(wxID_ANY, wxT("すべてのログを削除"));
     deleteLog->Append(wxID_ANY, wxT("お気に入り以外のログを削除"));
     menu4->AppendSubMenu(deleteLog, wxT("ログ削除"));
     menu4->AppendSeparator();
     menu4->Append(wxID_ANY, wxT("このスレをチェック"));
     menu4->AppendSeparator();
     wxMenu *abone = new wxMenu;
     abone->Append(wxID_ANY, wxT("スレッドあぼ～ん"));
     abone->Append(wxID_ANY, wxT("透明スレッドあぼ～ん"));
     abone->Append(wxID_ANY, wxT("あぼ～ん・チェックを解除"));
     menu4->AppendSubMenu(abone, wxT("あぼ～ん"));
     menu4->AppendSeparator();
     wxMenu *sort = new wxMenu;
     sort->Append(ID_OnClickMenuCOL_CHK,       wxT("1 !"));
     sort->Append(ID_OnClickMenuCOL_NUM,       wxT("2 番号"));
     sort->Append(ID_OnClickMenuCOL_TITLE,     wxT("3 タイトル"));
     sort->Append(ID_OnClickMenuCOL_RESP,      wxT("4 レス"));
     sort->Append(ID_OnClickMenuCOL_CACHEDRES, wxT("5 取得"));
     sort->Append(ID_OnClickMenuCOL_NEWRESP,   wxT("6 新着"));
     sort->Append(ID_OnClickMenuCOL_INCRESP,   wxT("7 増レス"));
     sort->Append(ID_OnClickMenuCOL_MOMENTUM,  wxT("8 勢い"));
     sort->Append(ID_OnClickMenuCOL_LASTUP,    wxT("9 最終取得"));
     sort->Append(ID_OnClickMenuCOL_SINCE,     wxT("0 SINCE"));
     sort->Append(ID_OnClickMenuCOL_OID,       wxT("a 固有番号"));
     sort->Append(ID_OnClickMenuCOL_BOARDNAME, wxT("b 板"));
     sort->AppendSeparator();
     sort->AppendCheckItem(wxID_ANY, wxT("開いているスレを上へソート"));
     sort->AppendCheckItem(wxID_ANY, wxT("重要スレを上へソート"));
     menu4->AppendSubMenu(sort, wxT("ソート"));
     wxMenu *aboneB = new wxMenu;
     aboneB->AppendRadioItem(wxID_ANY, wxT("透明"));
     aboneB->AppendRadioItem(wxID_ANY, wxT("標準"));
     aboneB->AppendRadioItem(wxID_ANY, wxT("あぼ～ん無効"));
     aboneB->AppendRadioItem(wxID_ANY, wxT("あぼ～んのみ"));
     aboneB->AppendRadioItem(wxID_ANY, wxT("重要スレのみ"));
     menu4->AppendSubMenu(aboneB, wxT("スレッドあぼ～んの表示変更"));
     menu4->AppendSeparator();
     menu4->Append(wxID_ANY, wxT("過去ログ非表示"));
     /**
      * スレッド部分
      */
     wxMenu *menu5 = new wxMenu;
     wxMenu *closeTh = new wxMenu;
     closeTh->Append(ID_OneThreadTabClose, wxT("選択中のタブを閉じる"));
     closeTh->Append(wxID_ANY, wxT("未読として閉じる"));
     closeTh->AppendSeparator();
     closeTh->Append(ID_ExcepSelThreadTabClose, wxT("選択されていないタブを閉じる"));
     closeTh->Append(ID_AllThreadTabClose, wxT("すべてのタブを閉じる"));
     closeTh->Append(ID_AllLeftThreadTabClose, wxT("これより左を閉じる"));
     closeTh->Append(ID_AllRightThreadTabClose, wxT("これより右を閉じる"));
     closeTh->AppendSeparator();
     closeTh->Append(wxID_ANY, wxT("新着なしのタブを閉じる"));
     closeTh->Append(wxID_ANY, wxT("dat落ちのタブを閉じる"));
     menu5->AppendSubMenu(closeTh, wxT("閉じる"));
     menu5->AppendSeparator();
     wxMenu *tabLock = new wxMenu;
     tabLock->Append(wxID_ANY, wxT("このタブをロックする"));
     tabLock->Append(wxID_ANY, wxT("すべてのタブをロックする"));
     tabLock->Append(wxID_ANY, wxT("これより左をロックする"));
     tabLock->Append(wxID_ANY, wxT("これより右をロックする"));
     menu5->AppendSubMenu(tabLock, wxT("タブロック"));
     menu5->AppendSeparator();
     menu5->Append(wxID_ANY, wxT("次スレ候補検索"));
     menu5->Append(wxID_ANY, wxT("次スレ候補を開く"));
     menu5->AppendSeparator();
     menu5->Append(wxID_ANY, wxT("ヒストリー検索"));
     menu5->AppendSeparator();
     menu5->Append(wxID_ANY, wxT("印を付ける"));
     wxMenu *addFav = new wxMenu;
     addFav->Append(wxID_ANY, wxT("「お気に入り」に追加"));
     addFav->AppendSeparator();
     addFav->Append(wxID_ANY, wxT("「リンク」に追加"));
     menu5->AppendSubMenu(addFav, wxT("お気に入りに追加"));
     menu5->Append(wxID_ANY, wxT("お気に入りを削除"));
     menu5->AppendSeparator();
     menu5->Append(wxID_ANY, wxT("強制過去ログ化"));
     menu5->AppendSeparator();
     wxMenu *move = new wxMenu;
     move->Append(wxID_ANY, wxT("戻る"));
     move->Append(wxID_ANY, wxT("進む"));
     move->AppendSeparator();
     move->Append(wxID_ANY, wxT("閉じた付近に戻る"));
     move->Append(wxID_ANY, wxT("新着までスクロール"));
     move->Append(wxID_ANY, wxT("次のレス↓"));
     move->Append(wxID_ANY, wxT("前のレス↑"));
     move->AppendSeparator();
     move->Append(wxID_ANY, wxT("指定レス番号にジャンプ"));
     menu5->AppendSubMenu(move, wxT("移動"));
     menu5->AppendSeparator();
     menu5->Append(wxID_ANY, wxT("新着チェック"));
     menu5->Append(wxID_ANY, wxT("すべてのタブの新着チェック"));
     menu5->Append(wxID_ANY, wxT("すべてのタブの更新チェック"));
     menu5->Append(wxID_ANY, wxT("中止"));
     menu5->Append(wxID_ANY, wxT("レス"));
     menu5->AppendSeparator();
     menu5->Append(ID_OnOpenThreadByBrowser, wxT("ブラウザで開く"));
     menu5->AppendSeparator();
     wxMenu *broadcast = new wxMenu;
     broadcast->Append(wxID_ANY, wxT("オートリロード"));
     broadcast->Append(wxID_ANY, wxT("オートスクロール"));
     broadcast->Append(wxID_ANY, wxT("オートリロード・スクロール"));
     menu5->AppendSubMenu(broadcast, wxT("実況支援"));
     menu5->AppendSeparator();
     wxMenu *copyMenu5 = new wxMenu;
     copyMenu5->Append(ID_CopyTURLToClipBoard, wxT("URLをコピー"));
     copyMenu5->Append(ID_CopyTTitleToClipBoard, wxT("タイトルをコピー"));
     copyMenu5->Append(ID_CopyTBothDataToClipBoard, wxT("タイトルとURLをコピー"));
     menu5->AppendSubMenu(copyMenu5, wxT("コピー"));
     menu5->AppendSeparator();
     menu5->Append(wxID_ANY, wxT("この板を開く"));
     menu5->Append(wxID_ANY, wxT("この板の看板を見る"));
     menu5->AppendSeparator();
     wxMenu *saveLog = new wxMenu;
     saveLog->Append(ID_SaveDatFile, wxT("datを名前を付けて保存"));
     saveLog->Append(ID_SaveDatFileToClipBoard, wxT("datをクリップボードにコピー"));
     menu5->AppendSubMenu(saveLog, wxT("このログを保存"));
     menu5->Append(ID_DeleteDatFile, wxT("このログを削除"));
     menu5->Append(ID_ReloadThisThread, wxT("再読み込み"));
     menu5->AppendSeparator();
     wxMenu *iReadHere = new wxMenu;
     iReadHere->Append(wxID_ANY, wxT("この辺まで読んだ"));
     iReadHere->Append(wxID_ANY, wxT("最後まで読んだ"));
     iReadHere->Append(wxID_ANY, wxT("「ここまで読んだ」にジャンプ"));
     iReadHere->Append(wxID_ANY, wxT("「ここまで読んだ」を解除"));
     menu5->AppendSubMenu(iReadHere, wxT("ここまで読んだ"));
     wxMenu *chkResponse = new wxMenu;
     chkResponse->Append(wxID_ANY, wxT("レスのチェックをすべて解除"));
     menu5->AppendSubMenu(chkResponse, wxT("レスのチェック"));
     menu5->AppendSeparator();
     wxMenu *changeLocalAbone = new wxMenu;
     changeLocalAbone->AppendRadioItem(wxID_ANY, wxT("透明"));
     changeLocalAbone->AppendRadioItem(wxID_ANY, wxT("標準"));
     changeLocalAbone->AppendRadioItem(wxID_ANY, wxT("ポップアップ"));
     changeLocalAbone->AppendRadioItem(wxID_ANY, wxT("あぼ～ん無効"));
     changeLocalAbone->AppendRadioItem(wxID_ANY, wxT("あぼ～んのみ"));
     changeLocalAbone->AppendRadioItem(wxID_ANY, wxT("自分書込のみ"));
     changeLocalAbone->AppendRadioItem(wxID_ANY, wxT("自分返信のみ"));
     menu5->AppendSubMenu(changeLocalAbone, wxT("ローカルあぼ～ん表示の変更"));
     wxMenu *extractRedRes = new wxMenu;
     extractRedRes->Append(wxID_ANY, wxT("赤レス抽出"));
     extractRedRes->Append(wxID_ANY, wxT("被参照レス抽出"));
     extractRedRes->AppendSeparator();
     extractRedRes->Append(wxID_ANY, wxT("赤レスフィルタ"));
     extractRedRes->Append(wxID_ANY, wxT("被参照レス抽出フィルタ"));
     menu5->AppendSubMenu(extractRedRes, wxT("赤レス抽出"));

     /**
      * お気に入り部分
      */
     wxMenu *menu6 = new wxMenu;

     // ！ここはお気に入りスレッドを動的に確保する！

     /**
      * 検索部分
      */
     wxMenu *menu7 = new wxMenu;
     menu7->Append(wxID_ANY, wxT("検索"));
     menu7->Append(wxID_ANY, wxT("↓検索"));
     menu7->Append(wxID_ANY, wxT("↑検索"));
     menu7->AppendSeparator();
     menu7->Append(wxID_ANY, wxT("レス抽出"));
     menu7->AppendSeparator();
     menu7->Append(wxID_ANY, wxT("スレのツリー形式表示"));
     menu7->Append(wxID_ANY, wxT("スレのアウトライン表示"));
     menu7->AppendSeparator();
     menu7->Append(wxID_ANY, wxT("スレ絞込み"));
     menu7->Append(wxID_ANY, wxT("スレ絞込み結果クリア"));
     menu7->Append(wxID_ANY, wxT("ログから検索"));
     menu7->AppendSeparator();
     menu7->Append(wxID_ANY, wxT("スレッドタイトル検索"));
     menu7->Append(wxID_ANY, wxT("2chのURLにジャンプ"));
     menu7->AppendSeparator();
     menu7->Append(wxID_ANY, wxT("検索履歴削除"));
     /**
      * ウィンドウ部分
      */
     wxMenu* menu8 = new wxMenu;
     menu8->Append(ID_UserLookingTabsControl, wxT("閉じる"));
     menu8->AppendSeparator();
     menu8->Append(wxID_ANY, wxT("次のタブ"));
     menu8->Append(wxID_ANY, wxT("前のタブ"));
     menu8->AppendSeparator();
     menu8->Append(wxID_ANY, wxT("重ねて表示"));
     menu8->Append(wxID_ANY, wxT("左右に並べて表示"));
     menu8->Append(wxID_ANY, wxT("上下に並べて表示"));
     menu8->Append(wxID_ANY, wxT("すべて元のサイズに戻す"));
     menu8->Append(wxID_ANY, wxT("すべて最大化"));
     menu8->AppendSeparator();
     menu8->Append(ID_WindowMinimize, wxT("最小化"));
     menu8->AppendSeparator();
     this->lookingTB = new wxMenu();
     lookingTB->Append(ID_UserLookingTabsMenuUp, wxT("現在開いている板とスレッド"), wxT("現在開いている板とスレッドを開きます"));
     lookingTB->AppendSeparator();
     menu8->AppendSubMenu(lookingTB, wxT("現在開いている板とスレッド"), wxT("現在開いている板とスレッドを開きます"));
     /**
      * ツール部分
      */
     wxMenu *menu9 = new wxMenu;
     menu9->Append(wxID_ANY, wxT("更新チェック"));
     menu9->AppendSeparator();
     wxMenu *image = new wxMenu;
     image->Append(wxID_ANY, wxT("マウスオーバーで画像を開く"));
     image->Append(wxID_ANY, wxT("クリップボード監視"));
     image->AppendSeparator();
     image->Append(wxID_ANY, wxT("キャッシュ一覧"));
     menu9->AppendSubMenu(image, wxT("画像"));
     wxMenu *memo = new wxMenu;
     memo->Append(wxID_ANY, wxT("名前履歴消去"));
     memo->Append(wxID_ANY, wxT("メール履歴消去"));
     memo->AppendSeparator();
     memo->Append(wxID_ANY, wxT("次のメモ"));
     memo->Append(wxID_ANY, wxT("前のメモ"));
     memo->Append(wxID_ANY, wxT("名前をつけて保存"));
     memo->Append(wxID_ANY, wxT("ファイルを開く"));
     memo->Append(wxID_ANY, wxT("メモをクリア"));
     memo->Append(wxID_ANY, wxT("AA入力支援"));
     memo->Append(wxID_ANY, wxT("一つ前のレスを貼り付け"));
     memo->AppendSeparator();
     memo->Append(wxID_ANY, wxT("メモ欄の内容で書き込む"));
     menu9->AppendSubMenu(memo, wxT("メモ"));
     menu9->AppendSeparator();
     menu9->AppendCheckItem(wxID_ANY, wxT("サウンド"));
     menu9->AppendSeparator();
     menu9->Append(wxID_ANY, wxT("ビューア設定"));
     menu9->Append(wxID_ANY, wxT("設定"));
     /**
      * ヘルプ部分
      */
     wxMenu *menu10 = new wxMenu;
     menu10->Append(wxID_ANY, wxT("ヘルプ"));
     menu10->AppendSeparator();
     menu10->Append(ID_OnOpenJaneCloneOfficial, wxT("JaneClone公式サイトをブラウザで開く"));
     menu10->AppendSeparator();
     menu10->Append(wxID_ANY, wxT("2ちゃんねるビューア●に登録"));
     menu10->AppendSeparator();
     menu10->Append(wxID_ANY, wxT("アップデートチェック"));
     menu10->AppendSeparator();
     menu10->Append(wxID_ANY, wxT("バグレポート"));
     menu10->Append(ID_GetVersionInfo, wxT("バージョン情報を開く"));

     /** メニューバーにメニューをセットしてタイトルを付けておく */
     menuBar->Append(menu1, wxT("ファイル"));
     menu1->SetTitle(wxT("ファイル"));
     menuBar->Append(menu2, wxT("表示"));
     menu2->SetTitle(wxT("表示"));
     menuBar->Append(menu3, wxT("板覧"));
     menu3->SetTitle(wxT("板覧"));
     menuBar->Append(menu4, wxT("スレ覧"));
     menu4->SetTitle(wxT("スレ覧"));
     menuBar->Append(menu5, wxT("スレッド"));
     menu5->SetTitle(wxT("スレッド"));
     menuBar->Append(menu6, wxT("お気に入り"));
     menu6->SetTitle(wxT("お気に入り"));
     menuBar->Append(menu7, wxT("検索"));
     menu7->SetTitle(wxT("検索"));
     menuBar->Append(menu8, wxT("ウィンドウ"));
     menu8->SetTitle(wxT("ウィンドウ"));
     menuBar->Append(menu9, wxT("ツール"));
     menu9->SetTitle(wxT("ツール"));
     menuBar->Append(menu10, wxT("ヘルプ"));
     menu10->SetTitle(wxT("ヘルプ"));

     // Linuxではファイルごとクリップボードにコピーすることができない
#ifndef __WXMSW__
     menuBar->Enable(ID_SaveDatFileToClipBoard, false);
#endif

     SetMenuBar(menuBar);
     /**
      * メニューバー設置終わり
      */
}
/**
 * SetProperties
 * 前回からのデータ引継ぎ等の処理を行う。
 */
void JaneClone::SetProperties() {
     // wxGladeによる自動生成
     SetTitle(_("JaneClone"));
     SetSize(wxSize(960, 640));
     isDragging = false;
     isClicking = false;

     // ユーザーのホームディレクトリを取得
     wxDir workDir(::wxGetHomeDir());
     wxString jc = ::wxGetHomeDir() + wxFileSeparator + JANECLONE_DIR;
     wxDir jcDir(jc);

     // ユーザーのホームディレクトリに隠しフォルダがあるかどうか確認
     if (!workDir.HasSubDirs(JANECLONE_DIR)) {
	  
	  ::wxMkdir(jc);
	  wxDir jcDir(jc);
 
	  // 存在しない場合は初期化処理を実施する
	  InitializeJaneClone(jc, jcDir);
	  // sqliteの初期化を行う
	  SQLiteAccessor* sqliteAccessor = new SQLiteAccessor();
	  delete sqliteAccessor;
	  /** 板一覧更新を行う */

	  // ソケット通信を行う
	  SocketCommunication* socketCommunication = new SocketCommunication();
	  int rc = socketCommunication->DownloadBoardList(BOARD_LIST_PATH, BOARD_LIST_HEADER_PATH);
	  delete socketCommunication;

	  // 実行コード別のダイアログを出す
	  if (rc != 0) {
	       wxMessageBox(wxT("板一覧情報取得に失敗しました。ネットワークの接続状況を確認してください。"));
	  } else {
	       // もし板一覧情報テーブルが空でなければテーブルを削除しておく
	       if (SQLiteAccessor::TableHasData(wxT("BOARD_INFO"))) {
		    SQLiteAccessor::DropTable(wxT("BOARD_INFO"));
	       }
	       // 板一覧情報を展開し、SQLiteに設定する
	       wxString boardListPath = BOARD_LIST_PATH;
	       new ExtractBoardList(boardListPath.mb_str());

	       *m_logCtrl << wxT("(ヽ´ん`) 板一覧更新完了\n");
	  }

	  
     } else {
	  // sqliteの初期化を行う
	  SQLiteAccessor* sqliteAccessor = new SQLiteAccessor();
	  delete sqliteAccessor;
     }

     // 初回起動以外の際、確認のためディレクトリをチェックする
     wxDir chkDir(jc);

     // 設定ファイルの準備をする
     wxString configFile = chkDir.GetName() + wxFileSeparator + wxT("prop") + wxFileSeparator + APP_CONFIG_FILE;
     config = new wxFileConfig(wxT("JaneClone"), wxEmptyString, configFile, wxEmptyString, wxCONFIG_USE_LOCAL_FILE);

     // datフォルダ、propフォルダ、cacheフォルダが存在するか確認。無ければ確認＆フォルダを作成
     if (!chkDir.HasSubDirs(wxT("dat"))) {
	  ::wxMkdir(chkDir.GetName() + wxFileSeparator + wxT("dat"));
     }
     if (!chkDir.HasSubDirs(wxT("prop"))) {
	  ::wxMkdir(chkDir.GetName() + wxFileSeparator + wxT("prop"));
     }
     if (!chkDir.HasSubDirs(wxT("cache"))) {
	  ::wxMkdir(chkDir.GetName() + + wxFileSeparator + wxT("cache"));
     }

     // アプリ上部URL入力欄の画像つきボタンのサイズ調整
     m_url_input_button->SetSize(m_url_input_button->GetBestSize());
     // アプリ上部URL入力欄のフォント調整
     m_url_input->SetFont(wxFont(12, wxDEFAULT, wxNORMAL, wxNORMAL, 0, wxT("")));

     // ノートブックのサイズ調整
     wxSize client_size = GetClientSize();

     // 板名のツリーコントロールをクリックした場合表示されるwxAuiNoteBook
     boardNoteBook = new wxAuiNotebook(this, ID_BoardNoteBook, wxPoint(client_size.x, client_size.y), 
				       wxDefaultSize, wxAUI_NB_DEFAULT_STYLE | wxAUI_NB_WINDOWLIST_BUTTON);
     
     // 板名のツリーコントロールをクリックした場合表示されるwxAuiNoteBook
     threadNoteBook = new wxAuiNotebook(this, ID_ThreadNoteBook, wxPoint(client_size.x, client_size.y), 
					wxDefaultSize, wxAUI_NB_DEFAULT_STYLE | wxAUI_NB_WINDOWLIST_BUTTON);

     // 画像ビューアのインスタンスを作る
     imageViewer = new JaneCloneImageViewer(this, wxID_ANY, wxT("画像ビューア"));
     // 通常は隠しておく
     imageViewer->Show(false);
}
/**
 * JaneCloneを初回起動した場合に実行するメソッド
 */
void JaneClone::InitializeJaneClone(wxString& jc, wxDir& jcDir) {

     ::wxMkdir(jcDir.GetName() + wxFileSeparator + wxT("dat"));
     ::wxMkdir(jcDir.GetName() + wxFileSeparator + wxT("prop"));
     ::wxMkdir(jcDir.GetName() + wxFileSeparator + wxT("cache"));
}
/**
 * DoLayout
 * ユーザーが触る前のアプリのレイアウトを設定する
 * 前回の起動時にレイアウトに変更があった場合はそれを反映する
 */
void JaneClone::DoLayout() {
     // アプリ上部、URL入力欄のレイアウトを設定する
     wxBoxSizer* url_sizer = new wxBoxSizer(wxHORIZONTAL);
     url_sizer->Add(m_url_input, 1, wxEXPAND, 0);
     url_sizer->Add(m_url_input_button, 0, 0, 0);
     m_url_input_panel->SetSizer(url_sizer);

     // Auiマネージャーがどのフレームを管理するか示す
     m_mgr.SetManagedWindow(this);
     // それぞれのペインの情報を設定する
     SetJaneCloneAuiPaneInfo();
     // Auiマネージャーの設定を反映する
     m_mgr.Update();
     // 設定ファイルからレイアウト情報を読み取る
     wxString perspective;
     config->Read(wxT("Perspective"), &perspective, wxEmptyString);
     m_mgr.LoadPerspective((const wxString) perspective, true);

     int x, y;
     config->Read(wxT("FrameX"), &x, 640);
     config->Read(wxT("FrameY"), &y, 480);
     this->SetSize(x, y);

     int px, py;
     config->Read(wxT("FramePx"), &px, 0);
     config->Read(wxT("FramePy"), &py, 0);
     this->Move(px, py);

     // ウィンドウの最大化情報
     bool isMaximized;
     config->Read(wxT("IsMaximized"), &isMaximized, false);
     this->Maximize(isMaximized);

     // 初期設定はこのLayout()が呼ばれる前に行わなくてはいけない
     Layout();
     // end wxGlade
}
/**
 * SetJaneCloneAuiPaneInfo
 * AuiManagerのPaneInfoを設定する
 */
void JaneClone::SetJaneCloneAuiPaneInfo() {
     // 上部・検索バーを設定する
     wxAuiPaneInfo search;
     search.Name(wxT("searchbar"));
     search.Caption(wxT("検索バー"));
     search.Top();
     search.CloseButton(false);

     // 上部・URL入力欄を設定する
     wxAuiPaneInfo url;
     url.Name(wxT("urlbar"));
     url.MinSize(wxSize(0, 16));
     url.Caption(wxT("url"));
     url.Top();
     url.CloseButton(false);

     // 左側・板一覧のツリーコントロールを設定する
     wxAuiPaneInfo boardTree;
     boardTree.Name(wxT("boardTree"));
     boardTree.Caption(wxT("板一覧"));
     boardTree.Left();
     boardTree.CloseButton(false);
     boardTree.BestSize(100, 300);

     // 左側下部・ログ出力ウィンドウを設定する
     wxAuiPaneInfo logWindow;
     logWindow.Name(wxT("logWindow"));
     logWindow.Caption(wxT("ログ出力画面"));
     logWindow.Left();
     logWindow.CloseButton(false);
     logWindow.MaxSize(20, 20);

     // 右側上部・板一覧のノートブックとスレッド一覧リストが載ったウィンドウ
     wxAuiPaneInfo boardListThreadListInfo;
     boardListThreadListInfo.Name(wxT("boardListThreadListInfo"));
     boardListThreadListInfo.Caption(wxT("スレッド一覧"));
     boardListThreadListInfo.Right();
     boardListThreadListInfo.Center();
     boardListThreadListInfo.CloseButton(false);
     boardListThreadListInfo.BestSize(400, 400);

     // 右側下部・スレッド一覧タブとスレ表示画面が載ったウィンドウ
     wxAuiPaneInfo threadTabThreadContentInfo;
     threadTabThreadContentInfo.Name(wxT("threadTabThreadContentInfo"));
     threadTabThreadContentInfo.Caption(wxT("開いているスレ"));
     threadTabThreadContentInfo.Right();
     threadTabThreadContentInfo.Center();
     threadTabThreadContentInfo.CloseButton(false);
     threadTabThreadContentInfo.BestSize(400, 400);

     // Addの順番と反映がLinuxとWindowsで逆なので、順番をifdefで設定する
#ifdef __WXMSW__
     m_mgr.AddPane(m_search_ctrl, search);
     m_mgr.AddPane(m_url_input_panel, url);
     m_mgr.AddPane(m_boardTreePanel, boardTree);
     m_mgr.AddPane(m_logCtrl, logWindow);
     m_mgr.AddPane(boardNoteBook, boardListThreadListInfo);
     m_mgr.AddPane(threadNoteBook, threadTabThreadContentInfo);
#else
     m_mgr.AddPane(m_url_input_panel, url);
     m_mgr.AddPane(m_search_ctrl, search);
     m_mgr.AddPane(m_logCtrl, logWindow);
     m_mgr.AddPane(m_boardTreePanel, boardTree);
     m_mgr.AddPane(threadNoteBook, threadTabThreadContentInfo);
     m_mgr.AddPane(boardNoteBook, boardListThreadListInfo);
#endif
     // 各ウィンドウで識別用のラベルを設定する
     this->SetLabel(JANECLONE_WINDOW);
     m_search_ctrl->SetLabel(SEARCH_BAR);
     m_url_input_panel->SetLabel(URL_BAR);
     m_logCtrl->SetLabel(LOG_WINDOW);
     boardNoteBook->SetLabel(BOARD_NOTEBOOK);
     threadNoteBook->SetLabel(THREAD_NOTEBOOK);
     m_boardTreePanel->SetLabel(BOARD_TREE_PANEL);

     // 板一覧更ツリーの初期化
     InitializeBoardList();

     // 前回設定されたフォント情報があれば設定する
     *m_logCtrl << wxT("前回使用したフォント情報の読み出し…\n");
     m_search_ctrl->SetFont(ReadFontInfo(SEARCH_BAR));
     m_url_input_panel->SetFont(ReadFontInfo(URL_BAR));
     m_logCtrl->SetFont(ReadFontInfo(LOG_WINDOW));
     boardNoteBook->SetFont(ReadFontInfo(BOARD_NOTEBOOK));
     threadNoteBook->SetFont(ReadFontInfo(THREAD_NOTEBOOK));
     *m_logCtrl << wxT("フォント情報の読み出し終了…\n");
}
/**
 * SetPreviousUserLookedTab
 * ユーザーが前回までに見ていた板一覧タブとスレッド一覧タブをセットする
 */
void JaneClone::SetPreviousUserLookedTab() {

     wxArrayString userLookedBoardList = SQLiteAccessor::GetUserLookedBoardList();

     for (unsigned int i = 0; i < userLookedBoardList.GetCount(); i++) {

	  wxString boardName = userLookedBoardList[i];

	  // 板名に対応したURLを取ってくる
	  URLvsBoardName hash = retainHash[boardName];
	  wxString boardNameAscii = hash.boardNameAscii;

	  // ファイルのパスを設定する
	  wxString outputPath = ::wxGetHomeDir() 
	       + wxFileSeparator 
	       + JANECLONE_DIR
	       + wxFileSeparator
	       + wxT("dat")
	       + wxFileSeparator
	       + boardNameAscii
	       + wxFileSeparator
	       + boardNameAscii
	       + wxT(".dat");

	  // 板一覧タブをセットする
	  std::map<wxString, ThreadList> stub;
	  SetThreadListItemNew(boardName, outputPath, i, stub);
     }

     wxArrayString userLookedThreadList = SQLiteAccessor::GetUserLookedThreadList();

     for (unsigned int i = 0; i < userLookedThreadList.GetCount(); i+= 3) {

	  wxString title = userLookedThreadList[i];
	  wxString origNumber = userLookedThreadList[i+1];
	  wxString boardNameAscii = userLookedThreadList[i+2];

	  // ファイルパスの組み立てとファイルの有無確認
	  wxString threadContentPath = JaneCloneUtil::AssembleFilePath(boardNameAscii, origNumber);

	  // ファイルの有無確認
	  if (!wxFile::Exists(threadContentPath)) {
	       // 無ければ警告を出して次へ
	       wxMessageBox(wxT("前回読み込んでいたdatファイルの読み出しに失敗しました"));
	       continue;
	  }

	  // スレッドの内容をノートブックに反映する
	  SetThreadContentToNoteBook(threadContentPath, origNumber, title);
	  // ノートブックに登録されたスレッド情報をハッシュに登録する
	  ThreadInfo info;
	  info.origNumber = origNumber;
	  info.boardNameAscii = boardNameAscii;
	  tiHash[title] = info;
     }
}
/**
 * デストラクタ
 */
JaneClone::~JaneClone() {
     // Auiマネージャーを削除する
     m_mgr.UnInit();
     delete config;
}
/**
 * JaneCloneを終了させる
 */
void JaneClone::OnQuit(wxCommandEvent&) {

     // Auiマネージャーを削除する
     m_mgr.UnInit();
     Close(true);
}
/**
 * JaneCloneを再起動する
 */
void JaneClone::OnRestart(wxCommandEvent& event) {

#ifdef __WXMSW__
     this->pid = wxGetProcessId();
     Close(true);
#else
     // ここはどうしたものやら
     this->Hide();
     wxSleep(1);
     this->Show();
#endif
}
/**
 * 板一覧のツリーがクリックされたときに起きるイベント
 */
void JaneClone::OnGetBoardInfo(wxTreeEvent& event) {

     // 選択されたTreeItemIdのインスタンス
     wxTreeItemId pushedTree = event.GetItem();

     // もし選択されたツリーが板名だったら(※TreeItemに子要素が無かったら)
     if (!m_tree_ctrl->ItemHasChildren(pushedTree)) {
	  // 板名をwxStringで取得する
	  wxString boardName(m_tree_ctrl->GetItemText(pushedTree));

	  // 取得した板名が取得不可なものであればリターン
	  if (boardName == wxEmptyString || boardName == wxT("2ch板一覧"))
	       return;

	  // URLを保持する文字列
	  wxString boardURL;
	  // サーバー名を保持する文字列
	  wxString boardNameAscii;

	  // 板名に対応したURLを取ってくる
	  URLvsBoardName hash = retainHash[boardName];
	  boardNameAscii = hash.boardNameAscii;
	  boardURL = hash.boardURL;

	  // 板一覧のツリーをクリックして、それをノートブックに反映するメソッド
	  SetBoardNameToNoteBook(boardName, boardURL, boardNameAscii);
     }
}
/**
 * 板一覧のツリーをクリックして、それをノートブックに反映するメソッド
 */
void JaneClone::SetBoardNameToNoteBook(wxString& boardName, wxString& boardURL, wxString& boardNameAscii) {

     // 以前ダウンロードしていたスレッドの情報をmap化する
     std::map<wxString, ThreadList> oldThreadMap;
     URLvsBoardName boardInfo;
     boardInfo.boardName      = boardName;
     boardInfo.boardURL	      = boardURL;
     boardInfo.boardNameAscii = boardNameAscii;
     // map化の実行
     JaneCloneUtil::GenerateOldThreadMap(oldThreadMap, boardInfo);

     // スレ一覧をダウンロードする
     SocketCommunication* socketCommunication = new SocketCommunication();
     socketCommunication->SetLogWindow(m_logCtrl);
     wxString outputPath = socketCommunication->DownloadThreadList(boardName, boardURL, boardNameAscii);
     delete socketCommunication;

     // 新規にセットされる板名かどうかのフラグを用意する
     bool itIsNewBoardName = true;
     // 次に選択されるべきタブのページ数を格納する変数
     size_t selectedPage = 0;

     // ユーザーが開いているタブの板名を調べる
     for (unsigned int i = 0; i < boardNoteBook->GetPageCount(); i++) {
	  if (boardName.Cmp(boardNoteBook->GetPageText(i)) == 0) {
	       itIsNewBoardName = false;
	       selectedPage = i;
	       break;
	  }
     }

     if (itIsNewBoardName) {
	  // もし新規のダウンロードだった場合、選択されるべきページを指定
	  selectedPage = boardNoteBook->GetPageCount();
	  SetThreadListItemNew((const wxString) boardName, (const wxString) outputPath, 
			       (const size_t) selectedPage, oldThreadMap);
     } else {
	  // 更新処理の場合、選択されるべきページはi
	  SetThreadListItemUpdate((const wxString) boardName, (const wxString) outputPath, 
				  (const size_t) selectedPage, oldThreadMap);
     }
}
/**
 * ノートブックに、新規にダウンロードされたスレッド一覧情報を反映するメソッド
 */
void JaneClone::SetThreadListItemNew(const wxString boardName, const wxString outputPath, 
				     const size_t selectedPage, std::map<wxString,ThreadList>& oldThreadMap) {

     // wxAuiToolBarを宣言する
     wxPanel* panel = CreateAuiToolBar(boardNoteBook, boardName, outputPath);
     // スレッドリストを表示させる
     boardNoteBook->AddPage(panel, boardName, false);
     // ノートブックの選択処理
     boardNoteBook->SetSelection(selectedPage);
}
/**
 * ノートブックに、スレッド一覧情報の更新を反映するメソッド
 */
void JaneClone::SetThreadListItemUpdate(const wxString boardName, const wxString outputPath, 
					const size_t selectedPage, std::map<wxString,ThreadList>& oldThreadMap) {

     // HashMapから対象の板のオブジェクトを取り出す
     if (vbListCtrlHash.find(boardName) == vbListCtrlHash.end()) {
	  wxMessageBox(wxT("スレッド一覧更新処理に失敗しました。"));
	  boardNoteBook->Thaw();
     } else {
	  // ハッシュ内部の情報を削除する
	  vbListCtrlHash.erase(boardName);
	  vbListHash.erase(boardName);
	  // wxAuiToolBarを宣言する
	  wxPanel* panel = CreateAuiToolBar(boardNoteBook, boardName, outputPath);     
	  boardNoteBook->DeletePage(selectedPage);
	  boardNoteBook->InsertPage(selectedPage, panel, boardName, false, wxNullBitmap);
	  // ノートブックの選択処理
	  boardNoteBook->SetSelection(selectedPage);
     }
}
/**
 * 板一覧更新処理
 */
void JaneClone::OnGetBoardList(wxCommandEvent&) {

     *m_logCtrl << wxT("三┏（ ；´ん｀）┛…板一覧更新\n");

     // ソケット通信を行う
     SocketCommunication* socketCommunication = new SocketCommunication();
     int rc = socketCommunication->DownloadBoardList(BOARD_LIST_PATH, BOARD_LIST_HEADER_PATH);
     delete socketCommunication;

     // 実行コード別のダイアログを出す
     if (rc != 0) {
	  wxMessageBox(wxT("板一覧情報取得に失敗しました。ネットワークの接続状況を確認してください。"));
     } else {
	  // もし板一覧情報テーブルが空でなければテーブルを削除しておく
	  if (SQLiteAccessor::TableHasData(wxT("BOARD_INFO"))) {
	       SQLiteAccessor::DropTable(wxT("BOARD_INFO"));
	  }
	  // 板一覧情報を展開し、SQLiteに設定する
	  wxString boardListPath = BOARD_LIST_PATH;
	  new ExtractBoardList(boardListPath.mb_str());
	  // 板一覧更新
	  SetBoardList();
	  
	  *m_logCtrl << wxT("　　　(ヽ´ん`) 完了\n");
     }
}
/**
 * HtmlWindow上でマウスホバーが起きた場合の処理
 */
void JaneClone::OnCellHover(wxHtmlCellEvent& event) {

     wxHtmlCell* cell = event.GetCell();
     wxHtmlLinkInfo* linkInfo = cell->GetLink(cell->GetPosX(), cell->GetPosY());

     if (linkInfo) {
	  if (linkInfo->GetHref() != wxEmptyString && linkInfo->GetTarget()
	      == _T("_blank")) {
	       // レスアンカーを察知した場合の処理
	       // <a>タグ内サンプル　<a href="../test/read.cgi/poverty/1345636335/20" target="_blank">
	       wxString href = linkInfo->GetHref();
	       wxStringTokenizer tkz(href, wxT("//"));
	       wxString boardNameAscii, orgNumber, resNumber;

	       while (tkz.HasMoreTokens()) {
		    wxString tmp = tkz.GetNextToken();
		    if (tmp == _T("read.cgi")) {
			 boardNameAscii = tkz.GetNextToken();
			 orgNumber = tkz.GetNextToken();
			 resNumber = tkz.GetNextToken();
			 break;
		    }
	       }

	       if (orgNumber == wxEmptyString || resNumber == wxEmptyString
		   || boardNameAscii == wxEmptyString) {
		    return;
	       }
	       // アンカーの出現位置
	       wxPoint anchorPoint(cell->GetPosX(), cell->GetPosY());
	       // 取得した情報を元に新しいポップアップウィンドウを出現させる
	       SetPopUpWindow(event, boardNameAscii, orgNumber, resNumber, anchorPoint);
	  }
     }
}
/**
 * スレッド一覧ノートブックで、タブが消される前の処理
 */
void JaneClone::OnAboutCloseThreadNoteBook(wxAuiNotebookEvent& event) {

     // 消されようとしているタブのタイトルを取得
     wxString title = threadNoteBook->GetPageText(threadNoteBook->GetSelection());
     // 固有番号を取得
     wxString origNumber = tiHash[title].origNumber;
     // スレッドの情報をSQLiteに格納する
     ThreadInfo t;
     t.title = title;
     t.origNumber = origNumber;
     t.boardNameAscii = tiHash[title].boardNameAscii;
     SQLiteAccessor::SetClosedThreadInfo(&t);
     // ハッシュからタイトルのキーを持つデータを削除
     tiHash.erase(title);
}
/**
 * 板一覧ノートブックで、タブが消される前の処理
 */
void JaneClone::OnAboutCloseBoardNoteBook(wxAuiNotebookEvent& event) {

     // 消されようとしているタブのタイトルを取得
     wxString boardName = boardNoteBook->GetPageText(boardNoteBook->GetSelection());
     URLvsBoardName hash = retainHash[boardName];
     SQLiteAccessor::SetClosedBoardInfo(&hash);
     // ハッシュからタイトルのキーをもつデータを削除
     retainHash.erase(boardName);
}
/**
 * アクティブな板タブをひとつ閉じる
 */
void JaneClone::OneBoardTabClose(wxCommandEvent & event) {

     // アクティブなタブを選択して閉じる
     boardNoteBook->DeletePage(boardNoteBook->GetSelection());
}
/**
 * 現在選択されていないスレッド一覧タブを閉じる
 */
void JaneClone::ExcepSelTabClose(wxCommandEvent & event) {

     // タブの数を数える
     size_t pages = boardNoteBook->GetPageCount();
     size_t select = boardNoteBook->GetSelection();
     bool delete_f = false;

     for (unsigned int i=0;i<pages;i++) {

	  if (i != select && !delete_f) {
	       boardNoteBook->DeletePage(0);
	  } else if (i == select && !delete_f) {
	       boardNoteBook->DeletePage(1);
	       delete_f = true;
	  } else if (i != select && delete_f) {
	       boardNoteBook->DeletePage(1);
	  }
     }
}
/**
 * すべてのスレッド一覧タブを閉じる
 */
void JaneClone::AllBoardTabClose(wxCommandEvent& event) {

     int pages = boardNoteBook->GetPageCount();
     for (int i=0;i<pages;i++) {
	  boardNoteBook->DeletePage(0);
     }
}
/**
 *　これより左のスレッド一覧タブをを閉じる
 */
void JaneClone::AllLeftBoardTabClose(wxCommandEvent& event) {

     // タブの数を数える
     size_t select = boardNoteBook->GetSelection();

     for (unsigned int i=0;i<select;i++) {
	  boardNoteBook->DeletePage(0);
     }
}
/**
 *　これより右のスレッド一覧タブを閉じる
 */
void JaneClone::AllRightBoardTabClose(wxCommandEvent& event) {

     // タブの数を数える
     size_t pages = boardNoteBook->GetPageCount();
     size_t select = boardNoteBook->GetSelection();
     for (unsigned int i=0;i<pages;i++) {
	  if (i>select) {
	       boardNoteBook->DeletePage(select+1);
	  }
     }
}
/**
 * スレッド一覧をブラウザで開く
 */
void JaneClone::OnOpenBoardByBrowser(wxCommandEvent& event) {

     wxString boardName = boardNoteBook->GetPageText(boardNoteBook->GetSelection());
     URLvsBoardName hash = retainHash[boardName];
     wxLaunchDefaultBrowser(hash.boardURL);
}
/**
 * アクティブなスレッド一覧をひとつ更新する
 */
void JaneClone::ReloadOneBoard(wxCommandEvent& event) {

     size_t page = boardNoteBook->GetSelection();
     wxString boardName = boardNoteBook->GetPageText(page);
     URLvsBoardName hash = retainHash[boardName];
     SetBoardNameToNoteBook(boardName, hash.boardURL, hash.boardNameAscii);
}
/**
 * 板のURLをクリップボードにコピーする
 */
void JaneClone::CopyBURLToClipBoard(wxCommandEvent& event) {

     wxString boardName = boardNoteBook->GetPageText(
	  boardNoteBook->GetSelection());
     URLvsBoardName hash = retainHash[boardName];

     if (wxTheClipboard->Open()) {
	  wxTheClipboard->Clear();
	  wxTheClipboard->SetData(new wxTextDataObject(hash.boardURL));
	  wxTheClipboard->Close();
     }
}
/**
 * 板のタイトルをクリップボードにコピーする
 */
void JaneClone::CopyBTitleToClipBoard(wxCommandEvent& event) {

     wxString boardName = boardNoteBook->GetPageText(
	  boardNoteBook->GetSelection());

     if (wxTheClipboard->Open()) {
	  wxTheClipboard->Clear();
	  wxTheClipboard->SetData(new wxTextDataObject(boardName));
	  wxTheClipboard->Close();
     }
}
/**
 * 板のURLとタイトルをクリップボードにコピーする
 */
void JaneClone::CopyBBothDataToClipBoard(wxCommandEvent& event) {

     wxString boardName = boardNoteBook->GetPageText(
	  boardNoteBook->GetSelection());
     URLvsBoardName hash = retainHash[boardName];

     if (wxTheClipboard->Open()) {
	  wxTheClipboard->Clear();
	  wxTheClipboard->SetData(new wxTextDataObject(boardName + wxT("\n") + hash.boardURL));
	  wxTheClipboard->Close();
     }
}
/**
 * スレッドのURLをクリップボードにコピーする
 */
void JaneClone::CopyTURLToClipBoard(wxCommandEvent& event) {

     const wxString title = threadNoteBook->GetPageText(threadNoteBook->GetSelection());
     const wxString boardNameAscii = tiHash[title].boardNameAscii;
     const wxString origNumber = tiHash[title].origNumber;

     wxString threadURL = GetThreadURL(title, boardNameAscii, origNumber);

     if (wxTheClipboard->Open()) {
	  wxTheClipboard->Clear();
	  wxTheClipboard->SetData(new wxTextDataObject(threadURL));
	  wxTheClipboard->Close();
     }
}
/**
 * スレッドのタイトルをクリップボードにコピーする
 */
void JaneClone::CopyTTitleToClipBoard(wxCommandEvent& event) {

     wxString title = threadNoteBook->GetPageText(threadNoteBook->GetSelection());

     if (wxTheClipboard->Open()) {
	  wxTheClipboard->Clear();
	  wxTheClipboard->SetData(new wxTextDataObject(title));
	  wxTheClipboard->Close();
     }
}
/**
 * スレッドのURLとタイトルをクリップボードにコピーする
 */
void JaneClone::CopyTBothDataToClipBoard(wxCommandEvent& event) {

     wxString title, boardNameAscii, origNumber, boardURL;

     title = threadNoteBook->GetPageText(
	  threadNoteBook->GetSelection());
     boardNameAscii = tiHash[title].boardNameAscii;
     origNumber = tiHash[title].origNumber;

     // 仕方がないので総当りでハッシュからURLを探す
     NameURLHash::iterator it;
     for (it = retainHash.begin(); it != retainHash.end(); ++it) {
	  wxString key = it->first;
	  URLvsBoardName value = it->second;

	  if (value.boardNameAscii == boardNameAscii) {
	       boardURL = value.boardURL;
	       break;
	  }
     }

     wxString threadURL = boardURL;

     // ホスト名の後の板名を除く
     int begin = threadURL.Find(boardNameAscii);
     if (begin == wxNOT_FOUND) {
	  return;
     }
     threadURL = threadURL.Mid(0, begin);
     threadURL += wxT("test/read.cgi/");
     threadURL += boardNameAscii;
     threadURL += wxT("/");
     threadURL += origNumber;
     threadURL += wxT("/");

     if (wxTheClipboard->Open()) {
	  wxTheClipboard->SetData(new wxTextDataObject(title + wxT("\n") + threadURL));
	  wxTheClipboard->Close();
     }
}
/**
 * 保存されているログをスレッド一覧に表示する
 */
void JaneClone::CheckLogDirectory(wxCommandEvent& event) {

     // ファイルパスの組み立て
     wxDir jcDir(::wxGetHomeDir() + wxFileSeparator + JANECLONE_DIR);
     wxString filePath = jcDir.GetName() + wxFileSeparator + wxT("dat");     

     // datファイルパスを開く
     wxDir datDir(filePath);
     if ( !datDir.IsOpened() )
	  return;

     wxString dirName = datDir.GetName();
     wxArrayString allFileList;
     datDir.GetAllFiles(dirName, &allFileList, wxEmptyString, wxDIR_DIRS | wxDIR_FILES);
     allFileList.Shrink();

     // datファイルのみの配列に置き換える
     wxArrayString datList;

     for (unsigned int i=0;i < allFileList.GetCount();i++) {
	  wxFileName* filename = new wxFileName(allFileList[i], wxPATH_NATIVE);
	  if(filename->GetName().IsNumber() && allFileList[i].Contains(wxT(".dat"))) {
	       // ファイル名が数字10桁で拡張子が「.dat」のものを取得する
	       datList.Add(allFileList[i]);
	  }
     }
     datList.Shrink();

     // ノートブックの変更中はノートブックに触れないようにする
     boardNoteBook->Freeze();

     // 新規にセットされる板名かどうかのフラグを用意する
     bool itIsNewBoardName = true;
     // 次に選択されるべきタブのページ数を格納する変数
     size_t selectedPage = 0;
     // 板名は「ログ一覧」で固定する
     wxString boardName = wxT("ログ一覧");

     // ユーザーが開いているタブの板名を調べる
     for (unsigned int i = 0; i < boardNoteBook->GetPageCount(); i++) {
	  if (boardName.Cmp(boardNoteBook->GetPageText(i)) == 0) {
	       itIsNewBoardName = false;
	       selectedPage = i;
	       break;
	  }
     }

     // 仮想リストのインスタンス（スコープの外で宣言したい）
     VirtualBoardListCtrl* vbListCtrl;

     if (itIsNewBoardName) {
	  /*
	   * 新規にログ一覧を作成する場合
	   */

	  // ログ一覧用のインスタンスを準備する
	  vbListCtrl = new VirtualBoardListCtrl(boardNoteBook, boardName, datList);

	  //　boardName(key),boardTabAndTh(value)としてHashに格納する
	  vbListCtrlHash[(const wxString) boardName] = (const VirtualBoardListCtrl&) vbListCtrl;
	  // listctrl内のリストをJaneCloneのメモリに持たせる
	  vbListHash[(const wxString) boardName] = vbListCtrl->m_vBoardList;
	  // スレッドリストを表示させる
	  boardNoteBook->AddPage(vbListCtrl, boardName, false);

     } else {
	  /*
	   * 既にログ一覧がタブにある場合
	   */

	  // ハッシュ内部の情報を削除する
	  vbListCtrlHash.erase(boardName);
	  vbListHash.erase(boardName);

	  // ログ一覧用のインスタンスを準備する
	  vbListCtrl = new VirtualBoardListCtrl(boardNoteBook, boardName, datList);

	  //　boardName(key),boardTabAndTh(value)としてHashに格納する
	  vbListCtrlHash[(const wxString) boardName] = (const VirtualBoardListCtrl&) vbListCtrl;
	  // listctrl内のリストをJaneCloneのメモリに持たせる
	  vbListHash[(const wxString) boardName] = vbListCtrl->m_vBoardList;

	  boardNoteBook->DeletePage(selectedPage);
	  boardNoteBook->InsertPage(selectedPage, vbListCtrl, boardName, false, wxNullBitmap);
     }

     // カラムの幅を最大化
#ifdef __WXMSW__
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_CHK      , 20);
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_TITLE    , wxLIST_AUTOSIZE);
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_SINCE    , wxLIST_AUTOSIZE);
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_OID      , wxLIST_AUTOSIZE);
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_BOARDNAME, wxLIST_AUTOSIZE);
#else
     // GTK+, Cocoaではリストの幅が適切に調整されないので
     // フォントの大きさから適切なリストの幅を算出する
     wxFont font = GetCurrentFont();
     int pointSize = font.GetPointSize();
     // 2chのスレタイの文字数制限は全角24文字
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_CHK      , 20);
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_TITLE    , pointSize * 52);
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_SINCE    , pointSize * 12);
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_OID      , pointSize * 10);
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_BOARDNAME, pointSize * 12);
#endif
     // ノートブックの選択処理
     boardNoteBook->SetSelection(selectedPage);
     boardNoteBook->Thaw();

     m_mgr.Update();
}
/**
 * スレタブをひとつ閉じる
 */
void JaneClone::OneThreadTabClose(wxCommandEvent& event) {

     // アクティブなタブを選択して閉じる
     threadNoteBook->DeletePage(threadNoteBook->GetSelection());
}
/**
 * 現在選択されていないスレタブを閉じる
 */
void JaneClone::ExcepSelThreadTabClose(wxCommandEvent& event) {

     // タブの数を数える
     size_t pages = threadNoteBook->GetPageCount();
     size_t select = threadNoteBook->GetSelection();
     bool delete_f = false;

     for (unsigned int i=0;i<pages;i++) {

	  if (i != select && !delete_f) {
	       threadNoteBook->DeletePage(0);
	  } else if (i == select && !delete_f) {
	       threadNoteBook->DeletePage(1);
	       delete_f = true;
	  } else if (i != select && delete_f) {
	       threadNoteBook->DeletePage(1);
	  }
     }
}
/**
 * すべてのスレタブを閉じる
 */
void JaneClone::AllThreadTabClose(wxCommandEvent& event) {

     int pages = threadNoteBook->GetPageCount();
     for (int i=0;i<pages;i++) {
	  threadNoteBook->DeletePage(0);
     }
}
/**
 * これより左のスレタブをを閉じる
 */
void JaneClone::AllLeftThreadTabClose(wxCommandEvent& event) {

     // タブの数を数える
     size_t select = threadNoteBook->GetSelection();

     for (unsigned int i=0;i<select;i++) {
	  threadNoteBook->DeletePage(0);
     }
}
/**
 * これより右のスレタブを閉じる
 */
void JaneClone::AllRightThreadTabClose(wxCommandEvent& event) {

     // タブの数を数える
     size_t pages = threadNoteBook->GetPageCount();
     size_t select = threadNoteBook->GetSelection();
     for (unsigned int i=0;i<pages;i++) {
	  if (i>select) {
	       threadNoteBook->DeletePage(select+1);
	  }
     }
}
/**
 * スレッドをブラウザで開く
 */
void JaneClone::OnOpenThreadByBrowser(wxCommandEvent& event) {

     CopyTURLToClipBoard(event);

     if (wxTheClipboard->Open()) {
	  wxTextDataObject data;
	  wxTheClipboard->GetData(data);
	  wxString url = data.GetText();
	  wxTheClipboard->Close();
	  wxLaunchDefaultBrowser(url);
     }
}
/**
 * datファイルに名前を付けて保存
 */
void JaneClone::SaveDatFile(wxCommandEvent& event) {

     wxString caption = wxT("datファイルに名前を付けて保存");
     wxString defaultDir = wxEmptyString; // OSのデフォルトに合わせる
     wxString wildCard = wxT("dat files (*.dat) |*.dat");

     // datファイル名の組み立て
     wxString title, boardNameAscii, origNumber, boardURL;

     title = threadNoteBook->GetPageText(threadNoteBook->GetSelection());
     boardNameAscii = tiHash[title].boardNameAscii;
     origNumber = tiHash[title].origNumber;

     // ファイルパスの組み立てとファイルの有無確認
     wxString filePath = JaneCloneUtil::AssembleFilePath(boardNameAscii, origNumber);

     if (!wxFile::Exists(filePath)) {
	  // 無ければエラーメッセージ表示
	  wxMessageBox(wxT("保存するためのdatファイルが見つかりませんでした"));
	  return;
     }

     wxFileDialog dialog(this, caption, defaultDir, wxEmptyString, wildCard, wxFD_SAVE);
     dialog.SetPath(filePath);

     if (dialog.ShowModal() == wxID_OK) {
	  bool ret = wxCopyFile(filePath, dialog.GetPath(), true);
	  if (!ret) {
	       wxMessageBox(wxT("datファイルの保存に失敗しました"));
	  }
     }
}
/**
 * datをクリップボードにコピー
 */
void JaneClone::SaveDatFileToClipBoard(wxCommandEvent& event) {

     // datファイル名の組み立て
     wxString title, boardNameAscii, origNumber, boardURL;

     title = threadNoteBook->GetPageText(threadNoteBook->GetSelection());
     boardNameAscii = tiHash[title].boardNameAscii;
     origNumber = tiHash[title].origNumber;

     // ファイルパスの組み立てとファイルの有無確認
     wxString filePath = JaneCloneUtil::AssembleFilePath(boardNameAscii, origNumber);

     if (!wxFile::Exists(filePath)) {
	  // 無ければエラーメッセージ表示
	  wxMessageBox(wxT("保存するためのdatファイルが見つかりませんでした"));
	  return;
     }

     if (wxTheClipboard->Open()) {
	  wxFileDataObject* file = new wxFileDataObject();
	  file->AddFile(filePath);

	  wxTheClipboard->Clear();
	  wxTheClipboard->SetData(file);
	  wxTheClipboard->Close();
     }
}
/**
 * このログを削除
 */
void JaneClone::DeleteDatFile(wxCommandEvent& event) {

     // datファイル名の組み立て
     wxString title, boardNameAscii, origNumber, boardURL;

     title = threadNoteBook->GetPageText(threadNoteBook->GetSelection());
     boardNameAscii = tiHash[title].boardNameAscii;
     origNumber = tiHash[title].origNumber;

     // ファイルパスの組み立てとファイルの有無確認
     wxString filePath = JaneCloneUtil::AssembleFilePath(boardNameAscii, origNumber);

     if (!wxFile::Exists(filePath)) {
	  // 無ければエラーメッセージ表示
	  wxMessageBox(wxT("削除するためのdatファイルが見つかりませんでした"));
	  return;
     }

     wxString message = wxT("ファイル") + filePath + wxT("を削除してよろしいですか？");
     int result = wxMessageBox(message, wxEmptyString, wxOK | wxNO);

     if (result == wxOK) {
	  wxRemoveFile(filePath);
     }
}
/**
 * スレッドの再読み込み
 */
void JaneClone::ReloadThisThread(wxCommandEvent& event) {

     // 選択されたスレタブの情報を集める
     wxString boardName,boardURL, title, origNumber, boardNameAscii;
     size_t page = threadNoteBook->GetSelection();
     title = threadNoteBook->GetPageText(threadNoteBook->GetSelection());
     ThreadInfo info = tiHash[title];
     origNumber = info.origNumber;
     boardNameAscii = info.boardNameAscii;

     // 仕方がないので総当りでハッシュからURLを探す
     NameURLHash::iterator it;
     for (it = retainHash.begin(); it != retainHash.end(); ++it) {
	  wxString key = it->first;
	  URLvsBoardName value = it->second;

	  if (value.boardNameAscii == boardNameAscii) {
	       boardName = value.boardName;
	       boardURL = value.boardURL;
	       break;
	  }
     }

     // アクティブなタブを選択して閉じる
     threadNoteBook->DeletePage(threadNoteBook->GetSelection());

     // ソケット通信を行う
     SocketCommunication* socketCommunication = new SocketCommunication();
     const wxString threadContentPath = socketCommunication->DownloadThread(boardName, boardURL, boardNameAscii, origNumber);
     delete socketCommunication;
     // 無事に通信が終了したならばステータスバーに表示
     this->SetStatusText(wxT(" スレッドのダウンロード終了"));

     // スレッド用の検索バー等のインスタンスを用意する
     ThreadContentBar* threadBar = new ThreadContentBar(threadNoteBook, wxID_ANY);
     threadBar->SetTitle(title);

     // スレッドの内容はThreadContentBarの中で設定する
     threadBar->SetThreadContentWindow(threadContentPath);

     // ノートブックに登録されたスレッド情報をハッシュに登録する
     info.origNumber = origNumber;
     info.boardNameAscii = boardNameAscii;
     tiHash[title] = info;

     *m_logCtrl << wxT("完了…　(´ん｀/)三\n");

     // スレッドを表示させる
     threadNoteBook->InsertPage(page, threadBar, title, false, wxNullBitmap);
     threadNoteBook->SetSelection(page);
}
/**
 *  書き込み用のウィンドウを呼び出す
 */
void JaneClone::CallResponseWindow(wxCommandEvent& event) {

     // 必要な構造体を宣言する
     ThreadInfo threadInfoHash;
     URLvsBoardName boardInfoHash;

     // 選択されたスレタブの情報を集める
     wxString title = threadNoteBook->GetPageText(threadNoteBook->GetSelection());
     threadInfoHash = tiHash[title];

     // ハッシュからURLを探す
     NameURLHash::iterator it;
     for (it = retainHash.begin(); it != retainHash.end(); ++it) {
	  wxString key = it->first;
	  boardInfoHash = it->second;

	  if (boardInfoHash.boardNameAscii == threadInfoHash.boardNameAscii) break;
     }

     // ウィンドウの大きさを取得する
     int wScreenPx, hScreenPx;
     ::wxDisplaySize(&wScreenPx, &hScreenPx);
     // レス用のウィンドウは 640:480なので、ちょうど中央にくるように調整する
     wxPoint point(wScreenPx/2 - 320, hScreenPx/2 - 240);
     ResponseWindow* response = new ResponseWindow((wxWindow*)this, title, boardInfoHash, threadInfoHash, point);
     // ログ出力ウィンドウのインスタンスのポインタを渡す
     response->SetLogWindow(m_logCtrl);
     response->Show(true);
}
/**
 * 板一覧更ツリーの初期化
 */
void JaneClone::InitializeBoardList() {
     
     // ArrayStringの形で板一覧情報を取得する
     wxArrayString boardInfoArray = SQLiteAccessor::GetBoardInfo();
     // カテゴリ名一時格納用
     wxString categoryName;
     // 板名一時格納用
     wxString boardName;
     // URL一時格納用
     wxString url;
     // Sizer
     wxBoxSizer* vbox = new wxBoxSizer(wxVERTICAL);
     // 検索用ツールバーを設定する
     CreateCommonAuiToolBar(m_boardTreePanel, vbox, ID_BoardSearchBar);

     // ツリー用ウィジェットのインスタンスを用意する
     m_tree_ctrl = new wxTreeCtrl(m_boardTreePanel, ID_BoardTreectrl, wxDefaultPosition, wxDefaultSize, 
				  wxTR_HAS_BUTTONS|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
     vbox->Add(m_tree_ctrl, 1, wxLEFT | wxRIGHT | wxEXPAND, 10);

     wxTreeItemData treeData;
     wxTreeItemId m_rootId;

     // イメージリストにアイコンを登録する
     wxImageList* treeImage = new wxImageList(16, 16);
     wxBitmap idx1(wxT("rc/folder.png"), wxBITMAP_TYPE_PNG);
     treeImage->Add(idx1);
     wxBitmap idx2(wxT("rc/text-html.png"), wxBITMAP_TYPE_PNG);
     treeImage->Add(idx2);
     m_tree_ctrl->AssignImageList(treeImage);
     m_tree_ctrl->SetLabel(BOARD_TREE);
     wxTreeItemId rootTemp = m_tree_ctrl->AddRoot(wxT("2ch板一覧"));
     m_tree_ctrl->SetItemImage(rootTemp, 0, wxTreeItemIcon_Normal);

     // カテゴリ名を保持するためのID
     wxTreeItemId category;
     // Hashのカウント用Integer
     int hashID = 0;

     // 板一覧情報をツリーに渡す
     for (unsigned int i = 0; i < boardInfoArray.GetCount(); i += 3) {

	  // カテゴリをツリーに登録
	  if (categoryName != boardInfoArray[i + 2]) {
	       category = m_tree_ctrl->AppendItem(m_tree_ctrl->GetRootItem(), boardInfoArray[i + 2]);
	       m_tree_ctrl->SetItemImage(category, 0, wxTreeItemIcon_Normal);
	  }
	  // それぞれの要素を一時格納
	  boardName = boardInfoArray[i];
	  url = boardInfoArray[i + 1];
	  categoryName = boardInfoArray[i + 2];

	  // ツリーに板名を追加する
	  wxTreeItemId itemIdTemp = m_tree_ctrl->AppendItem(category, boardName);
	  m_tree_ctrl->SetItemImage(itemIdTemp, 1, wxTreeItemIcon_Normal);

	  // 板名の配列に板名とURLを入れておく
	  URLvsBoardName urlVsName;
	  urlVsName.boardName = boardName;
	  urlVsName.boardURL = url;

	  // 正規表現を使ってサーバ名と板名(ascii)を取得する
	  // そこまで難しい正規表現を使う必要はないようです
	  wxRegEx reThreadList(_T("(http://)([^/]+)/([^/]+)"), wxRE_ADVANCED + wxRE_ICASE);

	  // 正規表現のコンパイルにエラーがなければ
	  if (reThreadList.IsValid()) {
	       // マッチさせる
	       if (reThreadList.Matches(url)) {
		    // マッチした文字列の３番目をいただく
		    urlVsName.boardNameAscii = reThreadList.GetMatch(url, 3);
	       }
	  }
	  // Hashに板情報を入れる
	  if (!boardName.IsEmpty())
	       retainHash[(const wxString) boardName]
		    = (const URLvsBoardName&) urlVsName;
	  // Hashのキー値をインクリメントしておく
	  hashID++;
     }

     m_tree_ctrl->Expand(m_rootId);

     // パネルにSizerを設定する
     m_boardTreePanel->SetSizer(vbox);
     m_boardTreePanel->Update();
}
/**
 * Sqliteから板一覧情報を抽出してレイアウトに反映するメソッド
 */
void JaneClone::SetBoardList(const bool thisIsFirst) {

     // ArrayStringの形で板一覧情報を取得する
     wxArrayString boardInfoArray = SQLiteAccessor::GetBoardInfo();
     // カテゴリ名一時格納用
     wxString categoryName;
     // 板名一時格納用
     wxString boardName;
     // URL一時格納用
     wxString url;
     // カテゴリ名を保持するためのID
     wxTreeItemId category;
     // Hashのカウント用Integer
     int hashID = 0;
     // 一度中身を削除する
     m_tree_ctrl->CollapseAndReset(m_tree_ctrl->GetRootItem());

     // 板一覧情報をツリーに渡す
     for (unsigned int i = 0; i < boardInfoArray.GetCount(); i += 3) {
	  // カテゴリをツリーに登録
	  if (categoryName != boardInfoArray[i + 2]) {
	       category = m_tree_ctrl->AppendItem(m_tree_ctrl->GetRootItem(), boardInfoArray[i + 2]);
	       m_tree_ctrl->SetItemImage(category, 0, wxTreeItemIcon_Normal);
	  }
	  // それぞれの要素を一時格納
	  boardName = boardInfoArray[i];
	  url = boardInfoArray[i + 1];
	  categoryName = boardInfoArray[i + 2];

	  // ツリーに板名を追加する
	  wxTreeItemId tmp = m_tree_ctrl->AppendItem(category, boardName);
	  m_tree_ctrl->SetItemImage(tmp, 1, wxTreeItemIcon_Normal);

	  // 板名の配列に板名とURLを入れておく
	  URLvsBoardName urlVsName;
	  urlVsName.boardName = boardName;
	  urlVsName.boardURL = url;

	  // 正規表現を使ってサーバ名と板名(ascii)を取得する
	  // そこまで難しい正規表現を使う必要はないようです
	  wxRegEx reThreadList(_T("(http://)([^/]+)/([^/]+)"), wxRE_ADVANCED + wxRE_ICASE);

	  // 正規表現のコンパイルにエラーがなければ
	  if (reThreadList.IsValid()) {
	       // マッチさせる
	       if (reThreadList.Matches(url)) {
		    // マッチした文字列の３番目をいただく
		    urlVsName.boardNameAscii = reThreadList.GetMatch(url, 3);
	       }
	  }
	  // Hashに板情報を入れる
	  if (!boardName.IsEmpty() && thisIsFirst)
	       retainHash[(const wxString) boardName] = (const URLvsBoardName&) urlVsName;
	  // Hashのキー値をインクリメントしておく
	  hashID++;
     }

     m_tree_ctrl->Expand(m_tree_ctrl->GetRootItem());
}
/**
 * バージョン情報が書かれたダイアログを表示する
 */
void JaneClone::OnVersionInfo(wxCommandEvent&) {

     wxAboutDialogInfo info;
     info.SetName(wxT("JaneClone - ２ちゃんねるビューア"));
     info.SetVersion(_T(STR(PACKAGE_VERSION)));
     info.SetDescription(wxT("Copyright(C) 2013 Nagata Hiroyuki, All Rights Reserved. "));
     info.SetCopyright(wxT("http://nantonaku-shiawase.hatenablog.com/"));

     wxAboutBox(info);
}
/**
 * 終了前処理では、保存しておきたいユーザー設定をSqliteに登録しておく
 */
void JaneClone::OnCloseWindow(wxCloseEvent& event) {

     // 終了処理中と表示する
     SetStatusText(wxT("終了前処理を実行中..."));

     /**
      * 開いていた板の名前をsqliteに登録する
      */
     wxArrayString userLookingBoardName;
     size_t bpages = boardNoteBook->GetPageCount();

     for (unsigned int i = 0; i < bpages; i++) {
	  wxString pageText = boardNoteBook->GetPageText((size_t) i);
	  // 空文字でなければ追加する
	  if (!pageText.IsEmpty()) {
	       userLookingBoardName.Add(pageText);
	  }
     }

     // 開いていた板の一覧をsqliteに送る
     SQLiteAccessor::SetUserLookingBoardList(userLookingBoardName);

     /**
      * 開いていたスレッドの情報をsqliteに登録する
      */
     wxArrayString userLookingThreadName;
     size_t tpages = threadNoteBook->GetPageCount();

     for (unsigned int i = 0; i < tpages; i++) {
	  wxString pageText = threadNoteBook->GetPageText((size_t) i);
	  // 空文字でなければ追加する
	  if (!pageText.IsEmpty()) {
	       userLookingThreadName.Add(pageText);
	       userLookingThreadName.Add(tiHash[pageText].origNumber);
	       userLookingThreadName.Add(tiHash[pageText].boardNameAscii);
	  }
     }
     // 開いていたスレッドの一覧をsqliteに送る
     SQLiteAccessor::SetUserLookingThreadList(userLookingThreadName);

     // wxAuiManagerのレイアウトの情報を保存する
     const wxString perspective = m_mgr.SavePerspective();
     config->Write(wxT("Perspective"), perspective);
     // フレームのレイアウト情報を保存する
     int x, y;
     this->GetSize(&x, &y);
     config->Write(wxT("FrameX"), x);
     config->Write(wxT("FrameY"), y);

     int px, py;
     this->GetPosition(&px, &py);
     config->Write(wxT("FramePx"), px);
     config->Write(wxT("FramePy"), py);

     // ウィンドウの最大化情報
     bool isMaximized = this->IsMaximized();
     config->Write(wxT("IsMaximized"), isMaximized);

     // 各ウィジェットのフォント情報
     wxWindowList& children = this->GetChildren();
     for ( wxWindowList::Node *node = children.GetFirst(); node; node = node->GetNext()) {
	  // boardNoteBookを親とするウィンドウクラスを引き出す
	  wxWindow *current = (wxWindow *)node->GetData();
	  WriteFontInfo(current);
     }

     SetStatusText(wxT("終了前処理が終わりました！"));

     Destroy();
}
/**
 * 板一覧リストでのクリック時のイベント
 */
void JaneClone::OnLeftClickAtListCtrl(wxListEvent& event) {

     *m_logCtrl << wxT("スレッド取得　三　(　＾ν）\n");
     // 現在アクティブになっているタブの板名を取得する
     wxString boardName = boardNoteBook->GetPageText(boardNoteBook->GetSelection());

     if (vbListCtrlHash.find(boardName) == vbListCtrlHash.end()) {
	  wxMessageBox(wxT("すでにダウンロードされているスレッド一覧ファイルの読み出しに失敗しました。datフォルダ内のデータを削除していませんか？"));
	  return;
     }

     // リストコントロールを引き出してくる
     VirtualBoardListCtrl* vbListCtrl = dynamic_cast<VirtualBoardListCtrl*>(wxWindow::FindWindowByName(boardName));
     if (vbListCtrl == NULL) {
	  wxMessageBox(wxT("内部エラー, スレッドダウンロード処理に失敗しました."), wxT("スレッド一覧リスト"), wxICON_ERROR);
	  return;
     }

     // Hashから情報を引き出す
     URLvsBoardName hash = retainHash[boardName];
     wxString boardURL = hash.boardURL;
     wxString boardNameAscii = hash.boardNameAscii;

     // スレの固有番号とタイトルをリストから取り出す
     const long index = event.GetIndex();
     const wxString origNumber(vbListCtrl->OnGetItemText(index, static_cast<long>(VirtualBoardListCtrl::Columns::COL_OID)));
     const wxString title(vbListCtrl->OnGetItemText(index, static_cast<long>(VirtualBoardListCtrl::Columns::COL_TITLE)));

     // ソケット通信を行う
     SocketCommunication* socketCommunication = new SocketCommunication();
     const wxString threadContentPath = socketCommunication->DownloadThread(
	  boardName, boardURL, boardNameAscii, origNumber);
     delete socketCommunication;
     // 無事に通信が終了したならばステータスバーに表示
     this->SetStatusText(wxT(" スレッドのダウンロード終了"));

     // スレッドの内容をノートブックに反映する
     SetThreadContentToNoteBook(threadContentPath, origNumber, title);
     // ノートブックに登録されたスレッド情報をハッシュに登録する
     ThreadInfo info;
     info.origNumber = origNumber;
     info.boardNameAscii = boardNameAscii;
     tiHash[title] = info;

     *m_logCtrl << wxT("完了…　(´ん｀/)三\n");
}
/**
 * スレッド一覧リストでリストのヘッダーにクリックした場合の処理
 */
void JaneClone::OnLeftClickAtListCtrlCol(wxListEvent& event) {
     
     // 現在アクティブになっているタブの板名を取得する
     wxString boardName = boardNoteBook->GetPageText(
	  boardNoteBook->GetSelection());

     if (vbListCtrlHash.find(boardName) == vbListCtrlHash.end()) {
	  wxMessageBox(wxT("すでにダウンロードされているスレッド一覧ファイルの読み出しに失敗しました。datフォルダ内のデータを削除していませんか？"));
     } else {

	  // リストコントロールを引き出してくる
	  VirtualBoardListCtrl* vbListCtrl = dynamic_cast<VirtualBoardListCtrl*>(wxWindow::FindWindowByName(boardName));
	  if (vbListCtrl == NULL) {
	       wxMessageBox(wxT("内部エラー, スレッドソート処理に失敗しました."), wxT("スレッド一覧リスト"), wxICON_ERROR);
	       return;
	  }

	  // 板名が一致するwindowクラスでソートをかける
	  vbListCtrl->SortVectorItems(event.GetColumn());
     }
}
/**
 * スレッドをノートブックに反映するメソッド
 */
void JaneClone::SetThreadContentToNoteBook(const wxString& threadContentPath,
					   const wxString& origNumber, const wxString& title) {

     // スレッド用の検索バー等のインスタンスを用意する
     ThreadContentBar* threadBar = new ThreadContentBar(threadNoteBook, wxID_ANY);
     threadBar->SetTitle(title);

     // スレッドの内容はThreadContentBarの中で設定する
     threadBar->SetThreadContentWindow(threadContentPath);
     threadNoteBook->AddPage(threadBar, title, true);
}
/**
 * 板一覧ノートブックで右クリックされた時の処理
 */
void JaneClone::OnRightClickBoardNoteBook(wxAuiNotebookEvent& event) {
     wxString selectedBoardName = boardNoteBook->GetPageText(
	  event.GetSelection());

     wxMenu* boardTabUtil = new wxMenu();
     boardTabUtil->Append(ID_OneBoardTabClose, wxT("このタブを閉じる"));
     boardTabUtil->AppendSeparator();
     boardTabUtil->Append(ID_ExcepSelTabClose, wxT("このタブ以外を閉じる"));
     boardTabUtil->Append(ID_AllBoardTabClose, wxT("すべてのタブを閉じる"));
     boardTabUtil->Append(ID_AllLeftBoardTabClose, wxT("これより左を閉じる"));
     boardTabUtil->Append(ID_AllRightBoardTabClose, wxT("これより右を閉じる"));
     boardTabUtil->AppendSeparator();
     boardTabUtil->Append(ID_ReloadOneBoard, wxT("スレ一覧更新"));
     boardTabUtil->Append(wxID_ANY, wxT("新着をすべて開く"));
     boardTabUtil->Append(wxID_ANY, wxT("お気に入りの新着をすべて開く"));
     boardTabUtil->Append(wxID_ANY, wxT("新着スレッドをすべて開く"));
     boardTabUtil->AppendSeparator();

     wxMenu* addFav = new wxMenu();
     addFav->Append(wxID_ANY, wxT("「お気に入り」に追加"));
     addFav->AppendSeparator();
     addFav->Append(wxID_ANY, wxT("「リンク」に追加"));
     boardTabUtil->AppendSubMenu(addFav, wxT("お気に入りに追加"));
     boardTabUtil->AppendSeparator();

     boardTabUtil->Append(wxID_ANY, wxT("スレッド新規作成"));
     boardTabUtil->AppendSeparator();
     boardTabUtil->Append(ID_OnOpenBoardByBrowser, wxT("ブラウザで開く"));
     boardTabUtil->Append(wxID_ANY, wxT("index表示"));
     boardTabUtil->Append(wxID_ANY, wxT("看板を見る"));
     boardTabUtil->AppendSeparator();

     boardTabUtil->AppendSeparator();
     wxMenu* copy = new wxMenu();
     copy->Append(ID_CopyBURLToClipBoard, wxT("URLをコピー"));
     copy->Append(ID_CopyBTitleToClipBoard, wxT("タイトルをコピー"));
     copy->Append(ID_CopyBBothDataToClipBoard, wxT("タイトルとURLをコピー"));
     boardTabUtil->AppendSubMenu(copy, wxT("コピー"));
     boardTabUtil->AppendSeparator();

     wxMenu* deleteLog = new wxMenu();
     deleteLog->Append(wxID_ANY, wxT("すべてのログを削除"));
     deleteLog->Append(wxID_ANY, wxT("お気に入り以外のログを削除"));
     boardTabUtil->AppendSubMenu(deleteLog, wxT("ログ削除"));
     boardTabUtil->AppendSeparator();

     boardTabUtil->Append(wxID_ANY, wxT("板移転の追尾"));
     boardTabUtil->AppendSeparator();
     boardTabUtil->Append(wxID_ANY, wxT("板のインデックスを再構築"));
     boardTabUtil->Append(wxID_ANY, wxT("過去ログ非表示"));

     // ポップアップメニューを表示させる
     PopupMenu(boardTabUtil);
}
/**
 * スレッド一覧ノートブックで右クリックされた時の処理
 */
void JaneClone::OnRightClickThreadNoteBook(wxAuiNotebookEvent& event) {
     wxString selectedThreadName = threadNoteBook->GetPageText(
	  event.GetSelection());

     wxMenu* threadTabUtil = new wxMenu();
     threadTabUtil->Append(ID_OneThreadTabClose, wxT("このタブを閉じる"));
     threadTabUtil->Append(wxID_ANY, wxT("未読として閉じる"));
     threadTabUtil->AppendSeparator();
     threadTabUtil->Append(ID_ExcepSelThreadTabClose, wxT("このタブ以外を閉じる"));
     threadTabUtil->Append(wxID_ANY, wxT("新着なしのタブを閉じる"));
     threadTabUtil->Append(ID_AllThreadTabClose, wxT("すべてのタブを閉じる"));
     threadTabUtil->Append(ID_AllLeftThreadTabClose, wxT("これより左を閉じる"));
     threadTabUtil->Append(ID_AllRightThreadTabClose, wxT("これより右を閉じる"));
     threadTabUtil->AppendSeparator();

     wxMenu *tabLock = new wxMenu;
     tabLock->Append(wxID_ANY, wxT("このタブをロックする"));
     tabLock->Append(wxID_ANY, wxT("すべてのタブをロックする"));
     tabLock->Append(wxID_ANY, wxT("これより左をロックする"));
     tabLock->Append(wxID_ANY, wxT("これより右をロックする"));
     threadTabUtil->AppendSubMenu(tabLock, wxT("タブロック"));
     threadTabUtil->AppendSeparator();

     threadTabUtil->Append(wxID_ANY, wxT("次スレ候補検索"));
     threadTabUtil->Append(wxID_ANY, wxT("次スレ候補を開く"));
     threadTabUtil->Append(wxID_ANY, wxT("ヒストリー検索"));
     threadTabUtil->AppendSeparator();

     threadTabUtil->Append(wxID_ANY, wxT("印を付ける"));

     wxMenu* addFav = new wxMenu();
     addFav->Append(wxID_ANY, wxT("「お気に入り」に追加"));
     addFav->AppendSeparator();
     addFav->Append(wxID_ANY, wxT("「リンク」に追加"));
     threadTabUtil->AppendSubMenu(addFav, wxT("お気に入りに追加"));
     threadTabUtil->AppendSeparator();

     wxMenu* addFavAll = new wxMenu();
     addFavAll->Append(wxID_ANY, wxT("「お気に入り」に追加"));
     addFavAll->AppendSeparator();
     addFavAll->Append(wxID_ANY, wxT("「リンク」に追加"));
     threadTabUtil->AppendSubMenu(addFavAll, wxT("すべてのタブをお気に入りに追加"));
     threadTabUtil->AppendSeparator();

     threadTabUtil->Append(wxID_ANY, wxT("新着チェック"));
     threadTabUtil->Append(wxID_ANY, wxT("すべてのタブの新着チェック"));
     threadTabUtil->Append(wxID_ANY, wxT("中止"));
     threadTabUtil->Append(ID_CallResponseWindow, wxT("レス"));
     threadTabUtil->AppendSeparator();
     threadTabUtil->Append(ID_OnOpenThreadByBrowser, wxT("ブラウザで開く"));
     threadTabUtil->AppendSeparator();

     wxMenu* copy = new wxMenu();
     copy->Append(ID_CopyTURLToClipBoard, wxT("URLをコピー"));
     copy->Append(ID_CopyTTitleToClipBoard, wxT("タイトルをコピー"));
     copy->Append(ID_CopyTBothDataToClipBoard, wxT("タイトルとURLをコピー"));
     threadTabUtil->AppendSubMenu(copy, wxT("コピー"));
     threadTabUtil->AppendSeparator();

     threadTabUtil->Append(wxID_ANY, wxT("この板を開く"));
     threadTabUtil->AppendSeparator();

     wxMenu *broadcast = new wxMenu;
     broadcast->Append(wxID_ANY, wxT("オートリロード"));
     broadcast->Append(wxID_ANY, wxT("オートスクロール"));
     broadcast->Append(wxID_ANY, wxT("オートリロード・スクロール"));
     threadTabUtil->AppendSubMenu(broadcast, wxT("実況支援"));
     threadTabUtil->AppendSeparator();

     wxMenu *iReadHere = new wxMenu;
     iReadHere->Append(wxID_ANY, wxT("この辺まで読んだ"));
     iReadHere->Append(wxID_ANY, wxT("最後まで読んだ"));
     iReadHere->Append(wxID_ANY, wxT("「ここまで読んだ」にジャンプ"));
     iReadHere->Append(wxID_ANY, wxT("「ここまで読んだ」を解除"));
     threadTabUtil->AppendSubMenu(iReadHere, wxT("ここまで読んだ"));

     wxMenu *chkResponse = new wxMenu;
     chkResponse->Append(wxID_ANY, wxT("レスのチェックをすべて解除"));
     threadTabUtil->AppendSubMenu(chkResponse, wxT("レスのチェック"));
     threadTabUtil->AppendSeparator();

     wxMenu *saveLog = new wxMenu;
     saveLog->Append(ID_SaveDatFile, wxT("datを名前を付けて保存"));
     saveLog->Append(ID_SaveDatFileToClipBoard, wxT("datをクリップボードにコピー"));
     threadTabUtil->AppendSubMenu(saveLog, wxT("このログを保存"));
     threadTabUtil->Append(ID_DeleteDatFile, wxT("このログを削除"));
     threadTabUtil->Append(ID_ReloadThisThread, wxT("再読み込み"));

     // Linuxではファイルごとクリップボードにコピーすることができない
#ifndef __WXMSW__
     saveLog->Enable(ID_SaveDatFileToClipBoard, false);
#endif

     // ポップアップメニューを表示させる
     PopupMenu(threadTabUtil);
}
/**
 * レスアンカーに対応するレスを表示するポップアップウィンドウを出現させる
 */
void JaneClone::SetPopUpWindow(wxHtmlCellEvent& event,
			       wxString& boardNameAscii, wxString& origNumber, wxString& resNumber,
			       wxPoint& anchorPoint) {

     // アンカーが指し示すHTMLソースを取得する
     wxString htmlDOM = JaneCloneUtil::FindAnchoredResponse(boardNameAscii,
							    origNumber, resNumber);

     if (wxEmptyString == htmlDOM) {
	  // 空文字で帰ってきたらリターン
	  return;
     }

     // 取得したレスをポップアップさせる
     AnchoredResponsePopup* popup = new AnchoredResponsePopup(threadNoteBook,
							      anchorPoint, wxSize(640, 300), htmlDOM);

     // マウスカーソルの位置に調整する
     wxPoint p = ClientToScreen(wxGetMousePosition());
     popup->Position(anchorPoint, wxSize(p.x + 50, p.y - 150));
     popup->Popup();
}
/**
 * 現在使用しているフォントの情報を取得する
 */
wxFont JaneClone::GetCurrentFont() {
     // wxFontのサンプルコードを参照
     wxFont font(wxNORMAL_FONT->GetPointSize(), wxFONTFAMILY_DEFAULT,
		 wxFONTSTYLE_NORMAL, wxFONTWEIGHT_NORMAL, false /* !underlined */,
		 wxEmptyString /* facename */, wxFONTENCODING_UTF8);

     if (font.IsOk()) {
	  return font;
     }
     // フォントが取得できなかった場合
     return *wxFont::New(10, wxFONTFAMILY_DEFAULT, wxFONTSTYLE_NORMAL,
			 wxFONTWEIGHT_NORMAL, false, wxEmptyString, wxFONTENCODING_UTF8);
}
/**
 * 板一覧ツリー部分のフォント設定を呼び出す
 */
void JaneClone::FontDialogBoardTree(wxCommandEvent& event) {
     SetFontDialog(ID_FontDialogBoardTree);
}
/**
 * ログ出力画面のフォント設定を呼び出す
 */
void JaneClone::FontDialogLogWindow(wxCommandEvent& event) {
     SetFontDialog(ID_FontDialogLogWindow);
}
/**
 * 板一覧画面部分のフォント設定を呼び出す
 */
void JaneClone::FontDialogBoardNotebook(wxCommandEvent& event) {
     SetFontDialog(ID_FontDialogBoardNotebook);
}
/**
 * スレッド画面部分のフォント設定を呼び出す
 */
void JaneClone::FontDialogThreadNotebook(wxCommandEvent& event) {
     SetFontDialog(ID_FontDialogThreadNotebook);
}
/**
 * スレッド内で使用するフォント設定を呼び出す
 */
void JaneClone::FontDialogThreadContents(wxCommandEvent& event) {
     
     wxFontData data;
     wxFont font;
     wxColour canvasTextColour;

     data.SetInitialFont(font);
     data.SetColour(canvasTextColour);
      
     wxFontDialog dialog((wxWindow*)this, data);
     if (dialog.ShowModal() == wxID_OK) {
	  // フォント設定用データを用意する
	  wxFontData retData = dialog.GetFontData();
	  font = retData.GetChosenFont();
     }

     // ex) Osaka
     wxString faceName = font.GetFaceName();
     config->Write(wxT("HTML.Font"), faceName);
     // ex) 10
     wxString pointSize = wxString::Format(_("%d"), font.GetPointSize());
     config->Write(wxT("HTML.PointSize"), pointSize);
     // 設定を反映するため再起動させる
     //this->pid = wxGetProcessId();
     //Close(true);
     this->Refresh();
     this->Update();
}
/**
 * フォント設定処理の本体
 */
void JaneClone::SetFontDialog(const int enumType) {

     wxFontData data;
     wxFont canvasFont;
     wxColour canvasTextColour;

     data.SetInitialFont(canvasFont);
     data.SetColour(canvasTextColour);
      
     wxFontDialog dialog((wxWindow*)this, data);
     if (dialog.ShowModal() == wxID_OK) {
	  // フォント設定用データを用意する
	  wxFontData retData = dialog.GetFontData();
	  canvasFont = retData.GetChosenFont();
	  canvasTextColour = retData.GetColour();

	  // とりあえずthisの子ウィンドウを取得して初期化しておく
	  wxWindowList& children = this->GetChildren();
	  wxString wannaChange;

	  // 設定対象ウィンドウを引き出してくる
	  switch (enumType) {

	  case ID_FontDialogBoardTree:
	       wannaChange = BOARD_TREE;
	       break;
	  case ID_FontDialogLogWindow:
	       wannaChange = LOG_WINDOW;
	       break;
	  case ID_FontDialogBoardNotebook:
	       wannaChange = BOARD_NOTEBOOK;
	       break;
	  case ID_FontDialogThreadNotebook:
	       wannaChange = THREAD_NOTEBOOK;
	       break;
	  }

	  for ( wxWindowList::Node *node = children.GetFirst(); node; node = node->GetNext()) {
	       // boardNoteBookを親とするウィンドウクラスを引き出す
	       wxWindow *current = (wxWindow *)node->GetData();
	       if (current->GetLabel() == wannaChange) {
		    current->SetFont(canvasFont);
		    current->Refresh();
		    current->Update();
		    break;
	       }   
	  }
     }
}
/**
 * フォント情報をコンフィグファイルに書き出す
 */
void JaneClone::WriteFontInfo(wxWindow* current) {

     if (current->GetLabel() == SEARCH_BAR) {
	  wxFont f = current->GetFont();
	  config->Write(SEARCH_BAR, f.GetNativeFontInfoDesc());
	  return;
     }

     if (current->GetLabel() == URL_BAR) {
	  wxFont f = current->GetFont();
	  config->Write(URL_BAR, f.GetNativeFontInfoDesc());
	  return; 
     }

     if (current->GetLabel() == BOARD_TREE) {
	  wxFont f = current->GetFont();
	  config->Write(BOARD_TREE, f.GetNativeFontInfoDesc());
	  return; 
     }

     if (current->GetLabel() == LOG_WINDOW) {
	  wxFont f = current->GetFont();
	  config->Write(LOG_WINDOW, f.GetNativeFontInfoDesc());
	  return; 
     }

     if (current->GetLabel() == BOARD_NOTEBOOK) {
	  wxFont f = current->GetFont();
	  config->Write(BOARD_NOTEBOOK, f.GetNativeFontInfoDesc());
	  return; 
     }

     if (current->GetLabel() == THREAD_NOTEBOOK) {
	  wxFont f = current->GetFont();
	  config->Write(THREAD_NOTEBOOK, f.GetNativeFontInfoDesc());
	  return; 
     }
}
/**
 * フォント情報をコンフィグファイルから読み出す
 */
wxFont JaneClone::ReadFontInfo(const wxString& widgetName) {

     wxString nativeFontInfo;
     config->Read(widgetName, &nativeFontInfo, wxEmptyString);
     wxFont f;
     bool ret = f.SetNativeFontInfo(nativeFontInfo);
     wxString result;

     (ret) ? result = wxT("OK")
	  : result = wxT("NG");

     // ログを出力する
     *m_logCtrl << nativeFontInfo + wxT(":") + result;

     return f;
}
/**
 * スレタブ上に存在するスレッドのURLを返す
 */
wxString JaneClone::GetThreadURL(const wxString title,const wxString boardNameAscii,
				 const wxString origNumber) {
     NameURLHash::iterator it;
     wxString threadURL;

     for (it = retainHash.begin(); it != retainHash.end(); ++it) {
	  wxString key = it->first;
	  const URLvsBoardName value = it->second;

	  if (value.boardNameAscii == boardNameAscii) {
	       threadURL = value.boardURL;
	       break;
	  }
     }

     // ホスト名の後の板名を除く
     int begin = threadURL.Find(boardNameAscii);
     if (begin == wxNOT_FOUND) {
	  return wxEmptyString;
     }
     threadURL = threadURL.Mid(0, begin);
     threadURL += wxT("test/read.cgi/");
     threadURL += boardNameAscii;
     threadURL += wxT("/");
     threadURL += origNumber;
     threadURL += wxT("/");

     return threadURL;
}
/**
 * 板一覧リストタブを変更した時のイベント
 */
void JaneClone::OnChangeBoardTab(wxAuiNotebookEvent& event) {

     // ノートブックの変更中はノートブックに触れないようにする
     boardNoteBook->Freeze();

     // 選択したタブのURLをURL画面に設定する
     if (wxEmptyString != boardNoteBook->GetPageText(event.GetSelection())) {
	  // 板一覧タブの場合
	  wxString boardName = boardNoteBook->GetPageText(boardNoteBook->GetSelection());
	  URLvsBoardName hash = retainHash[boardName];
	  m_url_input->SetValue(hash.boardURL);

     } else {
	  // その他などないのでエラー
	  *m_logCtrl << wxT("(ヽ´ん`)…板タブ変更時にエラーあったみたい…\n");
	  boardNoteBook->Thaw();
	  m_mgr.Update();

	  return;
     }

     // 選択したタブの板名を取得する
     wxString selectedBoardName = boardNoteBook->GetPageText(event.GetSelection());
     // リストコントロールを引き出してくる
     wxWindowList & children = boardNoteBook->GetChildren();
     for ( wxWindowList::Node *node = children.GetFirst(); node; node = node->GetNext()) {
	  // boardNoteBookを親とするウィンドウクラスを引き出す
	  wxWindow *current = (wxWindow *)node->GetData();

	  if (current->GetLabel() == selectedBoardName) {
	       // 板名が一致するwindowクラスを再描画させる
	       VirtualBoardListCtrl* vbListCtrl = (VirtualBoardListCtrl*)current;
	       vbListCtrl->GetItemCount();
	       break;
	  }	       
     }
     // タイトルを設定する
     SetTitle(selectedBoardName + wxT(" - JaneClone"));
     // ノートブックの解放
     boardNoteBook->Thaw();
     m_mgr.Update();
}
/**
 * スレッド一覧タブを変更した時のイベント
 */
void JaneClone::OnChangeThreadTab(wxAuiNotebookEvent& event) {

     // ノートブックの変更中はノートブックに触れないようにする
     threadNoteBook->Freeze();

     if (wxEmptyString != threadNoteBook->GetPageText(event.GetSelection())) {
	  // スレタブの場合
	  const wxString title = threadNoteBook->GetPageText(threadNoteBook->GetSelection());
	  const wxString boardNameAscii = tiHash[title].boardNameAscii;
	  const wxString origNumber = tiHash[title].origNumber;

	  // URL表示部分にスレッドのURLを設定する
	  wxString targetURL = GetThreadURL(title, boardNameAscii, origNumber);
	  m_url_input->SetValue(targetURL);

     } else {
	  // その他などないのでエラー
	  *m_logCtrl << wxT("(ヽ´ん`)…スレタブ変更時にエラーあったみたい…\n");
	  threadNoteBook->Thaw();
	  m_mgr.Update();

	  return;
     }

     threadNoteBook->Thaw();
     m_mgr.Update();
}
/**
 * 板一覧リストタブを変更した後のイベント
 */
void JaneClone::OnChangedBoardTab(wxAuiNotebookEvent& event) {

     // 選択したタブの板名を取得する
     wxString selectedBoardName = boardNoteBook->GetPageText(event.GetSelection());
     // タイトルを設定する
     SetTitle(selectedBoardName + wxT(" - JaneClone"));
}
/**
 * スレッド一覧タブを変更した後のイベント
 */
void JaneClone::OnChangedThreadTab(wxAuiNotebookEvent& event) {

     // 選択したタブのスレッド名を取得する
     wxString selectedThreadName = threadNoteBook->GetPageText(event.GetSelection());
     // タイトルを設定する
     SetTitle(selectedThreadName + wxT(" - JaneClone"));
}

void JaneClone::OnClickURLWindowButton(wxCommandEvent& event) {

     const wxString inputURL = m_url_input->GetValue();

     if (inputURL.Contains(wxT("/test/read.cgi/"))) {
	  // スレッドを表すURLの可能性がある場合
     } else {
	  // 板名を表すURLの可能性がある場合
     }
}
/**
 * メニューアイテムが開かれた場合呼ばれるイベント
 */
void JaneClone::OnMenuOpen(wxMenuEvent& event) {
     event.Skip();
}
/**
 * ユーザーが最近閉じたスレタブの情報をSQLiteから取得して設定する
 */
void JaneClone::UserLastClosedThreadMenuUp(wxUpdateUIEvent& event) {

     // メニューアイテムを順次消していく
     wxMenuItemList::Node* current_menuitem_node;
     wxMenuItem* current_menuitem;

     while ( current_menuitem_node = closeT->GetMenuItems().GetLast() ) {
	  current_menuitem = current_menuitem_node->GetData();
	  if (!current_menuitem->IsSeparator()) {
	       // menuの区切りでなければ削除する
	       closeT->Delete( current_menuitem );
	  } else {
	       // そうでなければ削除は終わりなので脱出
	       break;
	  }
     }
     // ユーザが閉じたスレッドのうち、データベースに保存されている数
     wxArrayString array = SQLiteAccessor::GetClosedThreadInfo();
     for (unsigned int i = 0; i < array.GetCount(); i++ ) {
	  closeT->Append(ID_UserLastClosedThreadClick, array[i]);
     }
}
/**
 * ユーザーが最近閉じた板タブの情報をSQLiteから取得して設定する
 */
void JaneClone::UserLastClosedBoardMenuUp(wxUpdateUIEvent& event) {

     // メニューアイテムを順次消していく
     wxMenuItemList::Node* current_menuitem_node;
     wxMenuItem* current_menuitem;

     while ( current_menuitem_node = closeB->GetMenuItems().GetLast() ) {
	  current_menuitem = current_menuitem_node->GetData();
	  if (!current_menuitem->IsSeparator()) {
	       // menuの区切りでなければ削除する
	       closeB->Delete( current_menuitem );
	  } else {
	       // そうでなければ削除は終わりなので脱出
	       break;
	  }
     }
     // ユーザが閉じたスレッドのうち、データベースに保存されている数
     wxArrayString array = SQLiteAccessor::GetClosedBoardInfo();
     for (unsigned int i = 0; i < array.GetCount(); i++ ) {
	  closeB->Append(ID_UserLastClosedBoardClick, array[i]);
     }
}
/**
 * ユーザーが現在開いているスレタブ、板タブの一覧を作成する
 */
void JaneClone::UserLookingTabsMenuUp(wxUpdateUIEvent& event) {
     
     // メニューアイテムを順次消していく
     wxMenuItemList::Node* current_menuitem_node;
     wxMenuItem* current_menuitem;

     while ( current_menuitem_node = lookingTB->GetMenuItems().GetLast() ) {
	  current_menuitem = current_menuitem_node->GetData();
	  if (!current_menuitem->IsSeparator()) {
	       // menuの区切りでなければ削除する
	       lookingTB->Delete( current_menuitem );
	  } else {
	       // そうでなければ削除は終わりなので脱出
	       break;
	  }
     }

     // menu8に現在ユーザーが開いているタブの名前を追加する
     wxArrayString array;

     for (unsigned int i = 0; i < boardNoteBook->GetPageCount(); i++) {
	  array.Add(boardNoteBook->GetPageText(i));
     }
     for (unsigned int i = 0; i < threadNoteBook->GetPageCount(); i++) {
	  array.Add(threadNoteBook->GetPageText(i));
     }
     for (unsigned int i = 0; i < array.GetCount(); i++ ) {
	  lookingTB->Append(ID_UserLookingTabsMenuClick, array[i]);
     }
}
/**
 * ユーザーが現在フォーカスしているウィンドウの操作を行う
 */
void JaneClone::UserLookingTabsControl(wxUpdateUIEvent& event) {
     event.Skip();
}
/**
 * フォーカスを変更した際に反応するイベント
 */
void JaneClone::OnSetFocus(wxFocusEvent& event) {
     event.Skip();
}
void JaneClone::MotionEnterWindow(wxMouseEvent& event) {
     event.Skip();
}
void JaneClone::MotionLeaveWindow(wxMouseEvent& event) {
     event.Skip();
}
/**
 * JaneClone公式サイトをブラウザで開く
 */
void JaneClone::OnOpenJaneCloneOfficial(wxCommandEvent& event) {
     wxLaunchDefaultBrowser(JANECLONE_DOWNLOADSITE);
}
/**
 * スレッド一覧画面にツールバーを設定する
 */
wxPanel* JaneClone::CreateAuiToolBar(wxWindow* parent, const wxString& boardName, const wxString& outputPath) {

     // スレッド検索ボックスとスレッド一覧リストを格納するサイザーを宣言する
     wxPanel* panel = new wxPanel(parent, -1);
     wxBoxSizer* vbox = new wxBoxSizer(wxVERTICAL);
     // 検索ツールバーをpanelとsizerに載せる
     CreateCommonAuiToolBar(panel, vbox, ID_ThreadSearchBar, boardName);

     // Hashに格納する板名タブのオブジェクトのインスタンスを準備する
     VirtualBoardListCtrl* vbListCtrl = new VirtualBoardListCtrl(
	  (wxWindow*) panel, (const wxString) boardName,
	  (const wxString) outputPath);
     vbListCtrl->SetName(boardName);
     vbox->Add(vbListCtrl, 1, wxLEFT | wxRIGHT | wxEXPAND, 10);

     //　boardName(key),boardTabAndTh(value)としてHashに格納する
     vbListCtrlHash[(const wxString) boardName] = (const VirtualBoardListCtrl&) vbListCtrl;
     // listctrl内のリストをJaneCloneのメモリに持たせる
     vbListHash[(const wxString) boardName] = vbListCtrl->m_vBoardList;

     // カラムの幅を最大化
#ifdef __WXMSW__
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_CHK      , 20);
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_TITLE    , wxLIST_AUTOSIZE);
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_SINCE    , wxLIST_AUTOSIZE);
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_OID      , wxLIST_AUTOSIZE);
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_BOARDNAME, wxLIST_AUTOSIZE);
#else
     // GTK+, Cocoaではリストの幅が適切に調整されないので
     // フォントの大きさから適切なリストの幅を算出する
     wxFont font = GetCurrentFont();
     int pointSize = font.GetPointSize();
     // 2chのスレタイの文字数制限は全角24文字
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_CHK      , 20);
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_TITLE    , pointSize * 52);
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_SINCE    , pointSize * 12);
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_OID      , pointSize * 10);
     vbListCtrl->SetColumnWidth(VirtualBoardListCtrl::Columns::COL_BOARDNAME, pointSize * 12);
#endif
     // パネルにSizerを設定する
     panel->SetSizer(vbox);

     return panel;
}
/**
 * 検索用ツールバー設定の共通部分
 */
void JaneClone::CreateCommonAuiToolBar(wxPanel* panel, wxBoxSizer* vbox, wxWindowID id, const wxString& boardName) {

     // wxAuiToolBarを宣言する
     wxAuiToolBar* searchBox = new wxAuiToolBar(panel, id, wxDefaultPosition, wxDefaultSize, wxAUI_TB_DEFAULT_STYLE | wxAUI_TB_OVERFLOW);
     searchBox->SetToolBitmapSize(wxSize(32,32));
     searchBox->AddTool(ID_SearchBoxDoSearch, SEARCH_BOX, wxBitmap(redResExtractImg, wxBITMAP_TYPE_ANY), wxT("検索"));
     // メニューの設定
     wxAuiToolBarItemArray prepend_items1;
     wxAuiToolBarItemArray append_items1;
     wxAuiToolBarItem item;
     // 後からどのウィンドウか判別するために、itemとwindowを関連付ける
     item.SetLabel(wxT("search_box_item"));
     item.SetWindow(searchBox);

     item.SetKind(wxITEM_NORMAL);
     item.SetId(ID_SearchBoxUp);
     item.SetLabel(wxT("↑検索"));
     append_items1.Add(item);

     item.SetKind(wxITEM_NORMAL);
     item.SetId(ID_SearchBoxDown);
     item.SetLabel(wxT("↓検索"));
     append_items1.Add(item);

     item.SetKind(wxITEM_NORMAL);
     item.SetId(ID_SearchBoxCopy);
     item.SetLabel(wxT("コピー"));
     append_items1.Add(item);

     item.SetKind(wxITEM_NORMAL);
     item.SetId(ID_SearchBoxCut);
     item.SetLabel(wxT("切り取り"));
     append_items1.Add(item);

     item.SetKind(wxITEM_NORMAL);
     item.SetId(wxID_ANY);
     item.SetLabel(wxT("貼り付け"));
     append_items1.Add(item);

     item.SetKind(wxITEM_NORMAL);
     item.SetId(ID_SearchBoxSelectAll);
     item.SetLabel(wxT("全て選択"));
     append_items1.Add(item);

     item.SetKind(wxITEM_NORMAL);
     item.SetId(ID_SearchBoxClear);
     item.SetLabel(wxT("クリア"));
     append_items1.Add(item);

     item.SetKind(wxITEM_SEPARATOR);
     append_items1.Add(item);

     item.SetKind(wxITEM_NORMAL);
     item.SetId(ID_SearchBarHide);
     item.SetLabel(wxT("閉じる"));
     append_items1.Add(item);
     searchBox->SetCustomOverflowItems(prepend_items1, append_items1);
     searchBox->AddTool(ID_SearchBoxRegexSearch, wxT("正規表現"), wxBitmap(regexImg, wxBITMAP_TYPE_ANY), wxT("正規表現を使います"), wxITEM_CHECK);

     if (id == ID_ThreadSearchBar) {
	  // ラベルを設定する
	  searchBox->SetLabel(THREADLIST_SEARCH);
	  // 検索ボックスを設定する
	  wxComboBox* searchWordCombo = new wxComboBox(searchBox, ID_ThreadSearchBarCombo, wxEmptyString, wxDefaultPosition, 
						       wxDefaultSize, 0, NULL, wxCB_DROPDOWN);
	  SupplySearchWords(searchWordCombo, ID_ThreadSearchBarCombo);

	  // スレッド検索ボックスのID
	  searchBox->AddControl(searchWordCombo, boardName + wxT("_combo"));
	  // 閉じるボタンを設定する
	  searchBox->AddTool(ID_SearchBarHide, wxT("closeThreadSearch"), wxBitmap(closeImg, wxBITMAP_TYPE_ANY), wxT("検索ボックスを隠す"));

     } else if (id == ID_BoardSearchBar) {
	  // ラベルを設定する
	  searchBox->SetLabel(BOARD_TREE_SEARCH);
	  // 検索ボックスを設定する
	  const wxArrayString choices = SQLiteAccessor::GetUserSearchedKeyword(ID_BoardSearchBarCombo);
	  wxComboBox* searchWordCombo = new wxComboBox(searchBox,
						       ID_BoardSearchBarCombo,
						       wxEmptyString, 
						       wxDefaultPosition, 
						       wxDefaultSize,  
						       choices, 
						       wxCB_DROPDOWN);

	  SupplySearchWords(searchWordCombo, ID_BoardSearchBarCombo);

	  // 板名検索ボックスのID
	  searchBox->AddControl(searchWordCombo, wxT("board_tree_combo"));
	  // 閉じるボタンを設定する
	  searchBox->AddTool(ID_SearchBarHide, wxT("closeThreadSearch"), wxBitmap(closeImg, wxBITMAP_TYPE_ANY), wxT("検索ボックスを隠す"));
     }

     searchBox->Realize();
     vbox->Add(searchBox, 0, wxLEFT | wxTOP, 10);
}
/**
 * 以前検索したキーワードをコンボボックスに補填する
 */
void JaneClone::SupplySearchWords(wxComboBox* combo, const wxWindowID id) {

}
/** 
 * 検索実行
 */
void JaneClone::SearchBoxDoSearch(wxCommandEvent& event) {

     wxWindow* window = dynamic_cast<wxWindow*>(event.GetEventObject());
     wxComboBox* combo = FindUserAttachedCombo(event, window);
     const wxString keyword = combo->GetValue();
     if (keyword.IsEmpty()) return;

     if (window != NULL && window->GetLabel() == BOARD_TREE_SEARCH) {
	  SearchBoardTree(keyword);
     } else if (window != NULL && window->GetLabel() == THREADLIST_SEARCH) {
	  SearchThreadList(keyword);
     }
     // コンボボックスに検索したキーワードをつめる
     combo->Append(keyword);
     SQLiteAccessor::SetUserSearchedKeyword(keyword, FindUserAttachedWindowId(event, window));
}
/**
 * 板一覧ツリーを検索する
 */
void JaneClone::SearchBoardTree(const wxString& keyword) {

     // ArrayStringの形で板一覧情報を取得する
     wxArrayString boardInfoArray = SQLiteAccessor::GetBoardInfo();
     // カテゴリ名一時格納用
     wxString categoryName;
     // 板名一時格納用
     wxString boardName;
     // URL一時格納用
     wxString url;
     // カテゴリ名を保持するためのID
     wxTreeItemId category;

     // 一度中身を削除する
     m_tree_ctrl->CollapseAndReset(m_tree_ctrl->GetRootItem());

     // 板一覧情報をツリーに渡す
     for (unsigned int i = 0; i < boardInfoArray.GetCount(); i += 3) {
	  // 板名がキーワードと一致する場合のみカテゴリをツリーに登録
	  if (categoryName != boardInfoArray[i + 2] && boardInfoArray[i].Contains(keyword)) {
	       category = m_tree_ctrl->AppendItem(m_tree_ctrl->GetRootItem(), boardInfoArray[i + 2]);
	       m_tree_ctrl->SetItemImage(category, 0, wxTreeItemIcon_Normal);
	  } else {
	       continue;
	  }
	  // それぞれの要素を一時格納
	  boardName = boardInfoArray[i];
	  url = boardInfoArray[i + 1];
	  categoryName = boardInfoArray[i + 2];

	  wxTreeItemId tmp = m_tree_ctrl->AppendItem(category, boardName);
	  m_tree_ctrl->SetItemImage(tmp, 1, wxTreeItemIcon_Normal);
	  m_tree_ctrl->Expand(category);
	  
     }

     m_tree_ctrl->Expand(m_tree_ctrl->GetRootItem());
}
/** 
 * スレッド一覧リストを検索する
 */
void JaneClone::SearchThreadList(const wxString& keyword) {
}
/**
 * スレッド検索ボックスを隠す
 */
void JaneClone::HideSearchBar(wxCommandEvent& event) {

     wxWindow* window = dynamic_cast<wxWindow*>(event.GetEventObject());
     if (window != NULL && (window->GetLabel() == BOARD_TREE_SEARCH || window->GetLabel() == THREADLIST_SEARCH)) {
	  window->Hide();
	  m_mgr.Update();
     }
}
/** 
 * 検索ボックスで上に移動
 */
void JaneClone::SearchBoxUp(wxCommandEvent& event) {
}
/** 
 * 検索ボックスで下に移動
 */
void JaneClone::SearchBoxDown(wxCommandEvent& event) {
}
/** 
 * 検索ボックスでコピー実行
 */
void JaneClone::SearchBoxCopy(wxCommandEvent& event) {

     wxWindow* window = dynamic_cast<wxWindow*>(event.GetEventObject());
     if (window == NULL) return;
     // 取得対象の検索ボックスを決める
     wxComboBox* combo = FindUserAttachedCombo(event, window);
     if (combo == NULL) return;
     // クリップボードに文字列をコピーする
     combo->Copy();
}
/** 
 * 検索ボックスで切り取り実行
 */
void JaneClone::SearchBoxCut(wxCommandEvent& event) {

     wxWindow* window = dynamic_cast<wxWindow*>(event.GetEventObject());
     if (window == NULL) return;
     // 取得対象の検索ボックスを決める
     wxComboBox* combo = FindUserAttachedCombo(event, window);
     if (combo == NULL) return;
     // コンボボックスから文字列を削除
     combo->Cut();
}
/**
 * 検索ボックスで全て選択
 */
void JaneClone::SearchBoxSelectAll(wxCommandEvent& event) {

     wxWindow* window = dynamic_cast<wxWindow*>(event.GetEventObject());
     if (window == NULL) return;
     // 取得対象の検索ボックスを決める
     wxComboBox* combo = FindUserAttachedCombo(event, window);
     if (combo == NULL) return;
     // コンボボックスの文字列を選択
     combo->SetSelection(0, combo->GetLastPosition() + 1);
}
/** 
 * 検索ボックスをクリア
 */
void JaneClone::SearchBoxClear(wxCommandEvent& event) {

     wxWindow* window = dynamic_cast<wxWindow*>(event.GetEventObject());
     if (window == NULL) return;
     // 取得対象の検索ボックスを決める
     wxComboBox* combo = FindUserAttachedCombo(event, window);
     if (combo == NULL) return;
     // コンボボックスの文字列をクリア
     combo->SetValue(wxEmptyString);

     if (window->GetLabel() == BOARD_TREE_SEARCH) {
	  // 板一覧ツリーも初期状態にもどす
	  SetBoardList(false);
     }
}
/**
 * アクティブなスレッド一覧リストをソートする
 */
void JaneClone::OnThreadListSort(wxCommandEvent& event) {

     // 現在アクティブになっているタブの板名を取得する
     wxString boardName = boardNoteBook->GetPageText(boardNoteBook->GetSelection());

     if (vbListCtrlHash.find(boardName) == vbListCtrlHash.end()) {
	  wxMessageBox(wxT("すでにダウンロードされているスレッド一覧ファイルの読み出しに失敗しました。datフォルダ内のデータを削除していませんか？"));
     } else {

	  // リストコントロールを引き出してくる
	  VirtualBoardListCtrl* vbListCtrl = dynamic_cast<VirtualBoardListCtrl*>(wxWindow::FindWindowByName(boardName));
	  if (vbListCtrl == NULL) {
	       wxMessageBox(wxT("内部エラー, スレッドソート処理に失敗しました."), wxT("スレッド一覧リスト"), wxICON_ERROR);
	       return;
	  }

	  switch(event.GetId()) {

	  case ID_OnClickMenuCOL_CHK:
	       vbListCtrl->SortVectorItems(VirtualBoardListCtrl::Columns::COL_CHK);
	       break;
	  case ID_OnClickMenuCOL_NUM:
	       vbListCtrl->SortVectorItems(VirtualBoardListCtrl::Columns::COL_NUM);
	       break;
	  case ID_OnClickMenuCOL_TITLE:
	       vbListCtrl->SortVectorItems(VirtualBoardListCtrl::Columns::COL_TITLE);
	       break;
	  case ID_OnClickMenuCOL_RESP:
	       vbListCtrl->SortVectorItems(VirtualBoardListCtrl::Columns::COL_RESP);
	       break;
	  case ID_OnClickMenuCOL_CACHEDRES:
	       vbListCtrl->SortVectorItems(VirtualBoardListCtrl::Columns::COL_CACHEDRES);
	       break;
	  case ID_OnClickMenuCOL_NEWRESP:
	       vbListCtrl->SortVectorItems(VirtualBoardListCtrl::Columns::COL_NEWRESP);
	       break;
	  case ID_OnClickMenuCOL_INCRESP:
	       vbListCtrl->SortVectorItems(VirtualBoardListCtrl::Columns::COL_INCRESP);
	       break;
	  case ID_OnClickMenuCOL_MOMENTUM:
	       vbListCtrl->SortVectorItems(VirtualBoardListCtrl::Columns::COL_MOMENTUM);
	       break;
	  case ID_OnClickMenuCOL_LASTUP:
	       vbListCtrl->SortVectorItems(VirtualBoardListCtrl::Columns::COL_LASTUP);
	       break;
	  case ID_OnClickMenuCOL_SINCE:
	       vbListCtrl->SortVectorItems(VirtualBoardListCtrl::Columns::COL_SINCE);
	       break;
	  case ID_OnClickMenuCOL_OID:
	       vbListCtrl->SortVectorItems(VirtualBoardListCtrl::Columns::COL_OID);
	       break;
	  case ID_OnClickMenuCOL_BOARDNAME:
	       vbListCtrl->SortVectorItems(VirtualBoardListCtrl::Columns::COL_BOARDNAME);
	       break;
	  default:
	       break;
	  }
     }     
}
